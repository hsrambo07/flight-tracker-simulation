// Map configuration variables
let MAP_WIDTH;
let MAP_HEIGHT;
let leafletMap; // Reference to the Leaflet map

// Expand MAP_BOUNDS to show more of Bangalore metropolitan area
const MAP_BOUNDS = {
  west: 77.2,
  east: 78.0,
  south: 12.6,
  north: 13.4
};

// Track animation state
let flightData = [];
let planeDivs = {};
let leafletMarkers = {}; // Store Leaflet markers for flights
let pathCanvases = {};
let animationRunning = false;
let recentFlights = []; // Store recent flight information for the sidebar
let lastSidebarUpdate = 0; // Track when sidebar was last updated

// FLIGHT HISTORY AND RETURN FLIGHT SYSTEM
let flightHistory = []; // Store completed flight logs
let completedFlightIds = new Set(); // Track which flights have completed
let returnFlightProbability = 0.4; // 40% chance of return flights
let nextReturnFlightId = 10000; // Start return flight IDs at 10000

// Add initialization state tracking
let isInitializing = true;
let initializationStartTime = 0;
let initializationDuration = 3000; // 3 seconds for smooth initialization

// Track pagination state
let currentPage = 0;
const flightsPerPage = 12; // Increased to better utilize scrolling

// Store sidebar state
let sidebarVisible = true;
let followingFlight = null; // Track which flight is being followed
let followingEnabled = false; // Whether flight following is active

// Tooltip state management
let tooltipTimeout = null;
let currentTooltipTarget = null;
let isTooltipVisible = false;

// Initialize Leaflet map
function initializeLeafletMap() {
  // Bangalore coordinates
  const bangaloreCenter = [13.0, 77.6]; // [latitude, longitude]
  
  // Create the map
  leafletMap = L.map('leaflet-map', {
    center: bangaloreCenter,
    zoom: 11,
    zoomControl: true, // Enable zoom controls for following mode
    attributionControl: true,
    dragging: true, // Enable dragging (will be disabled during following)
    touchZoom: true,
    doubleClickZoom: false,
    scrollWheelZoom: false,
    boxZoom: false,
    tap: false
  });
  
  // Add the OpenStreetMap tiles with a subtle style
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    maxZoom: 19
  }).addTo(leafletMap);
  
  // Add event listeners for map view changes
  leafletMap.on('zoomend moveend', function() {
    updateAllFlightPositions();
  });
  
  console.log("Leaflet map initialized centered on Bangalore");
}

// Update all flight positions when map view changes
function updateAllFlightPositions() {
  const now = Date.now();
  
  // Update canvas dimensions to match container
  const mapContainer = document.getElementById('map-container');
  if (mapContainer) {
    const containerRect = mapContainer.getBoundingClientRect();
    const newWidth = containerRect.width;
    const newHeight = containerRect.height;
    
    // Update all path canvases
    Object.values(pathCanvases).forEach(canvas => {
      if (canvas) {
        canvas.width = newWidth;
        canvas.height = newHeight;
      }
    });
  }
  
  flightData.forEach(flight => {
    const elapsedTime = now - flight.actualStartTime;
    const normalizedProgress = Math.min(1, Math.max(0, elapsedTime / flight.plannedDuration));
    let adjustedProgress = normalizedProgress * (1 + flight.windFactor * 0.3);
    adjustedProgress = Math.min(1, Math.max(0, adjustedProgress));
    
    const plane = planeDivs[flight.id];
    const pathCanvas = pathCanvases[flight.id];
    
    if (plane && pathCanvas) {
      // Check if flight is visible in current view
      const isVisible = isFlightVisibleInCurrentView(flight, adjustedProgress);
      
      if (isVisible) {
        plane.style.display = 'block';
        pathCanvas.style.display = 'block';
        
        // Get current path segment
        const totalPathPoints = flight.path.length - 1;
        const exactIndex = adjustedProgress * totalPathPoints;
        const currentIndex = Math.floor(exactIndex);
        const nextIndex = Math.min(currentIndex + 1, totalPathPoints);
        const segmentProgress = exactIndex - currentIndex;
        const currentPoint = flight.path[currentIndex];
        const nextPoint = flight.path[nextIndex];
        
        const flightInfo = calculateFlightInfo(flight, adjustedProgress, currentPoint, nextPoint, segmentProgress);
        updatePlanePosition(plane, flight, adjustedProgress, flightInfo);
        drawFlightPath(pathCanvas, flight, adjustedProgress);
      } else {
        plane.style.display = 'none';
        pathCanvas.style.display = 'none';
      }
    }
  });
}

// Check if flight is visible in current Leaflet view
function isFlightVisibleInCurrentView(flight, progress) {
  if (!leafletMap) return true;
  
  const exactIndex = progress * (flight.path.length - 1);
  const index = Math.floor(exactIndex);
  const nextIndex = Math.min(index + 1, flight.path.length - 1);
  const t = exactIndex - index;
  
  const currentPoint = flight.path[index];
  const nextPoint = flight.path[nextIndex];
  
  // Use great circle interpolation for current position
  const interpolatedPos = interpolateGreatCircle(
    currentPoint.lat, currentPoint.lon,
    nextPoint.lat, nextPoint.lon,
    t
  );
  
  // Check if position is within current map view
  const bounds = leafletMap.getBounds();
  return bounds.contains([interpolatedPos.lat, interpolatedPos.lon]);
}

// Initialize map dimensions based on current sidebar state
function initializeMapDimensions() {
  const sidebar = document.querySelector('.sidebar');
  let currentSidebarWidth = 280; // Default open width
  if (sidebar && sidebar.classList.contains('collapsed')) {
    currentSidebarWidth = 32; // Collapsed width
  }
  
  MAP_WIDTH = window.innerWidth - currentSidebarWidth;
  MAP_HEIGHT = window.innerHeight;
  
  console.log(`Map dimensions initialized: W=${MAP_WIDTH}, H=${MAP_HEIGHT}, SidebarW=${currentSidebarWidth}`);
}

// Add some static map features
function addMapFeatures() {
  // Ensure map dimensions are initialized
  initializeMapDimensions();
  
  const map = document.getElementById('flight-map');
  
  // Add state borders (simple dashed lines)
  const borders = [
    { lat: 12.9, label: "Bangalore City Boundary" },
    { lat: 13.1, label: "Northern District Boundary" },
    { lat: 12.85, label: "Southern District Boundary" }
  ];
  
  borders.forEach(border => {
    const y = convertLatToY(border.lat);
    const borderDiv = document.createElement('div');
    borderDiv.className = 'border';
    borderDiv.style.top = y + 'px';
    map.appendChild(borderDiv);
  });
  
  // Add city labels for Bangalore region
  const cities = [
    { name: "Bangalore", lat: 12.97, lon: 77.59 },
    { name: "Electronic City", lat: 12.84, lon: 77.67 },
    { name: "Whitefield", lat: 12.97, lon: 77.75 },
    { name: "Yelahanka", lat: 13.10, lon: 77.59 },
    { name: "Devanahalli", lat: 13.24, lon: 77.71 },
    { name: "Hosur", lat: 12.74, lon: 77.83 },
    { name: "Nelamangala", lat: 13.09, lon: 77.39 },
    { name: "Kengeri", lat: 12.90, lon: 77.48 }
  ];
  
  cities.forEach(city => {
    const x = convertLonToX(city.lon);
    const y = convertLatToY(city.lat);
    
    const cityDiv = document.createElement('div');
    cityDiv.className = 'map-feature';
    cityDiv.textContent = city.name;
    cityDiv.style.left = (x + 5) + 'px';
    cityDiv.style.top = y + 'px';
    map.appendChild(cityDiv);
  });
  
  // Add simple rivers/lakes (blue dots)
  const rivers = [
    { lat: 12.98, lon: 77.58, size: 15 }, // Ulsoor Lake
    { lat: 12.94, lon: 77.62, size: 20 }, // Cubbon Park
    { lat: 13.06, lon: 77.55, size: 12 }, // Hesarghatta Lake
    { lat: 12.89, lon: 77.60, size: 18 }, // Lalbagh Lake
    { lat: 12.92, lon: 77.67, size: 15 }, // Bellandur Lake
    { lat: 12.95, lon: 77.70, size: 25 }, // Varthur Lake
    { lat: 12.86, lon: 77.56, size: 15 }, // Hulimavu Lake
    { lat: 12.99, lon: 77.75, size: 20 }, // Whitefield Lake
    { lat: 13.04, lon: 77.50, size: 15 }  // Nagavara Lake
  ];
  
  rivers.forEach(river => {
    const x = convertLonToX(river.lon);
    const y = convertLatToY(river.lat);
    
    const riverDiv = document.createElement('div');
    riverDiv.className = 'river';
    riverDiv.style.left = (x - river.size/2) + 'px';
    riverDiv.style.top = (y - river.size/2) + 'px';
    riverDiv.style.width = river.size + 'px';
    riverDiv.style.height = river.size + 'px';
    map.appendChild(riverDiv);
  });
  
  // Add "Bangalore" label
  const usLabelDiv = document.createElement('div');
  usLabelDiv.className = 'map-feature';
  usLabelDiv.textContent = "Bangalore";
  usLabelDiv.style.left = (MAP_WIDTH / 2 - 40) + 'px';
  usLabelDiv.style.top = (MAP_HEIGHT / 2 + 50) + 'px';
  usLabelDiv.style.fontSize = '16px';
  usLabelDiv.style.color = '#999';
  map.appendChild(usLabelDiv);
  
  // Add airports (as landmarks)
  const airports = [
    // Main airports in/near visible area
    { code: "BLR", name: "Kempegowda International", lat: 13.1989, lon: 77.7068 },
    { code: "HAL", name: "HAL Bangalore Airport", lat: 12.9500, lon: 77.6687 },
    { code: "JKD", name: "Jakkur Aerodrome", lat: 13.0820, lon: 77.5893 },
    
    // Add more local airstrips and facilities within the region
    { code: "YLK", name: "Yelahanka Air Base", lat: 13.1042, lon: 77.5958 },
    { code: "BWD", name: "Bidar Airstrip", lat: 13.0867, lon: 77.7200 },
    { code: "HSR", name: "Hosur Airstrip", lat: 12.7409, lon: 77.8315 },
    { code: "TBD", name: "Tumkur Airfield", lat: 13.2067, lon: 77.3500 },
    { code: "MVL", name: "Mandya Flying Club", lat: 12.8200, lon: 77.2800 },
    { code: "CHT", name: "Chitradurga Airstrip", lat: 13.1650, lon: 77.8100 },
    { code: "MLR", name: "Mallur Helipad", lat: 12.9300, lon: 77.2900 },
    { code: "ELC", name: "Electronic City Helipad", lat: 12.8458, lon: 77.6700 },
    { code: "WTF", name: "Whitefield Heliport", lat: 12.9698, lon: 77.7500 },
    { code: "YPR", name: "Yelahanka Police Air Wing", lat: 13.0950, lon: 77.5800 },
    { code: "DVN", name: "Devanahalli Training Strip", lat: 13.2400, lon: 77.7200 },
    { code: "KGR", name: "Kengeri Private Strip", lat: 12.9079, lon: 77.4850 },
    
    // Regional airports slightly outside but relevant for flights passing through
    { code: "MYQ", name: "Mysore Airport", lat: 12.2300, lon: 76.6560 },
    { code: "HYD", name: "Hyderabad International", lat: 17.2403, lon: 78.4294 },
    { code: "MAA", name: "Chennai International", lat: 12.9941, lon: 80.1709 },
    { code: "COK", name: "Cochin International", lat: 10.1518, lon: 76.3930 },
    { code: "TRV", name: "Trivandrum International", lat: 8.4833, lon: 76.9200 },
    { code: "PNQ", name: "Pune International", lat: 18.5793, lon: 73.9089 },
    { code: "CCJ", name: "Kozhikode International", lat: 11.1356, lon: 75.9550 },
    { code: "CJB", name: "Coimbatore International", lat: 11.0300, lon: 77.0434 },
    { code: "DEL", name: "Delhi International", lat: 28.5562, lon: 77.1000 },
    { code: "BOM", name: "Mumbai International", lat: 19.0896, lon: 72.8656 },
    { code: "GOI", name: "Goa International", lat: 15.3808, lon: 73.8314 },
    // Add airports outside the main view for flights entering/exiting
    { code: "DXB", name: "Dubai International", lat: 25.2532, lon: 55.3657 },
    { code: "SIN", name: "Singapore Changi", lat: 1.3644, lon: 103.9915 },
    { code: "KUL", name: "Kuala Lumpur International", lat: 2.7456, lon: 101.7099 },
    { code: "BKK", name: "Bangkok Suvarnabhumi", lat: 13.6900, lon: 100.7501 },
    { code: "CMB", name: "Colombo Bandaranaike", lat: 7.1808, lon: 79.8844 },
    { code: "DOH", name: "Doha Hamad", lat: 25.2609, lon: 51.6138 }
  ];
  
  // Filter airports that are within the map bounds
  const visibleAirports = airports.filter(airport => {
    return airport.lon >= MAP_BOUNDS.west &&
           airport.lon <= MAP_BOUNDS.east &&
           airport.lat >= MAP_BOUNDS.south &&
           airport.lat <= MAP_BOUNDS.north;
  });
  
  visibleAirports.forEach(airport => {
    const x = convertLonToX(airport.lon);
    const y = convertLatToY(airport.lat);
    
    // Airport marker
    const airportDiv = document.createElement('div');
    airportDiv.className = 'airport';
    airportDiv.style.left = x + 'px';
    airportDiv.style.top = y + 'px';
    map.appendChild(airportDiv);
    
    // Airport label
    const labelDiv = document.createElement('div');
    labelDiv.className = 'airport-label';
    labelDiv.textContent = airport.code;
    labelDiv.style.left = x + 'px';
    labelDiv.style.top = y + 'px';
    map.appendChild(labelDiv);
  });
}

// Convert latitude to Y coordinate based on current Leaflet view
function convertLatToY(lat) {
  if (leafletMap) {
    // Use Leaflet's coordinate system
    const point = leafletMap.latLngToContainerPoint([lat, 0]);
    return point.y;
  } else {
    // Fallback to original calculation
    const latRange = MAP_BOUNDS.north - MAP_BOUNDS.south;
    const normalizedLat = (MAP_BOUNDS.north - lat) / latRange;
    return normalizedLat * MAP_HEIGHT;
  }
}

// Convert longitude to X coordinate based on current Leaflet view
function convertLonToX(lon) {
  if (leafletMap) {
    // Use Leaflet's coordinate system
    const point = leafletMap.latLngToContainerPoint([0, lon]);
    return point.x;
  } else {
    // Fallback to original calculation
    const lonRange = MAP_BOUNDS.east - MAP_BOUNDS.west;
    const normalizedLon = (lon - MAP_BOUNDS.west) / lonRange;
    return normalizedLon * MAP_WIDTH;
  }
}

// Convert coordinates to pixel positions using Leaflet if available
function coordsToPixels(lat, lon) {
  if (leafletMap) {
    const point = leafletMap.latLngToContainerPoint([lat, lon]);
    return {
      x: point.x,
      y: point.y
    };
  } else {
    return {
      x: convertLonToX(lon),
      y: convertLatToY(lat)
    };
  }
}

// Calculate heading: 0 is East (right), 90 is North (up), 180 is West (left), -90 is South (down)
function calculateHeading(startLat, startLon, endLat, endLon) {
  const startPixels = coordsToPixels(startLat, startLon);
  const endPixels = coordsToPixels(endLat, endLon);

  const dx = endPixels.x - startPixels.x;
  const dy = endPixels.y - startPixels.y; 

  // atan2(y,x) but for screen y is inverted for cartesian sense (dy is positive downwards)
  // To get a cartesian angle (0 East, 90 North), we use atan2(-dy, dx)
  let angle = Math.atan2(-dy, dx) * 180 / Math.PI;
  return (angle + 360) % 360; // Normalize to 0-360 if needed, though atan2 is usually -180 to 180
}

// Calculate distance between two points in nautical miles
function calculateDistanceNM(start, end) {
  const R = 3440.065; // Earth's radius in nautical miles
  const dLat = (end.lat - start.lat) * Math.PI / 180;
  const dLon = (end.lon - start.lon) * Math.PI / 180;
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(start.lat * Math.PI / 180) * Math.cos(end.lat * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// Interpolate between two points using great circle
function interpolateGreatCircle(lat1, lon1, lat2, lon2, t) {
  const R = 6371; // Earth's radius in km
  lat1 = lat1 * Math.PI / 180;
  lon1 = lon1 * Math.PI / 180;
  lat2 = lat2 * Math.PI / 180;
  lon2 = lon2 * Math.PI / 180;
  
  const d = 2 * Math.asin(Math.sqrt(
    Math.pow(Math.sin((lat1 - lat2) / 2), 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin((lon1 - lon2) / 2), 2)
  ));
  
  if (d === 0) return { lat: lat1 * 180 / Math.PI, lon: lon1 * 180 / Math.PI };
  
  const a = Math.sin((1 - t) * d) / Math.sin(d);
  const b = Math.sin(t * d) / Math.sin(d);
  
  const x = a * Math.cos(lat1) * Math.cos(lon1) + b * Math.cos(lat2) * Math.cos(lon2);
  const y = a * Math.cos(lat1) * Math.sin(lon1) + b * Math.cos(lat2) * Math.sin(lon2);
  const z = a * Math.sin(lat1) + b * Math.sin(lat2);
  
  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
  const lon = Math.atan2(y, x);
  
  return { lat: lat * 180 / Math.PI, lon: lon * 180 / Math.PI };
}

// Update Leaflet marker rotation to show aircraft heading
function updateLeafletRotation(marker, heading) {
  const markerElement = marker.getElement();
  if (markerElement) {
    const planeIcon = markerElement.querySelector('.plane-icon');
    if (planeIcon) {
      planeIcon.style.transform = `rotate(${heading - 90}deg)`;
    }
  }
}

// Create a flight with more mathematically accurate curved paths
function createFlight(start, end, color, id, airline, flightNumber) {
  const pathPoints = [];
  const numPoints = 150; // Reduce for smoother performance
  
  // Add some randomness to make each flight path unique
  const seedVal = id.charCodeAt(id.length - 1) % 10;
  const randomFactor = seedVal / 10; // 0.0-0.9
  
  // Calculate great circle distance for more accurate paths
  const directDistance = Math.sqrt(
    Math.pow(end.lat - start.lat, 2) + 
    Math.pow(end.lon - start.lon, 2)
  );
  
  // Calculate the midpoint between start and end
  const midLat = (start.lat + end.lat) / 2;
  const midLon = (start.lon + end.lon) / 2;
  
  // Reduce lateral deviation for more realistic paths but add SID procedure influence
  const maxDeviation = directDistance * 0.08; // Base deviation
  
  // ADD SOPHISTICATED SID DEPARTURE PROCEDURES
  // Different airports have different departure procedures that influence flight paths
  const departureAirportBias = {
    'BLR': { curvature: 0.15, preferredHeading: 270, turnDirection: 'left' },  // Bangalore SID procedures
    'DEL': { curvature: 0.12, preferredHeading: 90, turnDirection: 'right' },  // Delhi SID procedures  
    'BOM': { curvature: 0.18, preferredHeading: 180, turnDirection: 'left' },  // Mumbai SID procedures
    'MAA': { curvature: 0.14, preferredHeading: 45, turnDirection: 'right' },  // Chennai SID procedures
    'HYD': { curvature: 0.16, preferredHeading: 315, turnDirection: 'left' },  // Hyderabad SID procedures
    'CCU': { curvature: 0.13, preferredHeading: 135, turnDirection: 'right' }  // Kolkata SID procedures
  };
  
  // Get SID bias for departure airport or use default
  const sidBias = departureAirportBias[start.code] || { curvature: 0.15, preferredHeading: 0, turnDirection: 'straight' };
  
  // Apply SID-influenced path curvature (15% base plus airport-specific adjustments)
  const sidCurvature = sidBias.curvature * (1 + (randomFactor - 0.5) * 0.3); // ±15% variation based on seed
  const sidInfluencedDeviation = directDistance * sidCurvature;
  
  // Create waypoints with more natural curves
  const waypoints = [];
  
  // Always have a mid waypoint with controlled deviation
  const pathDeviation = (randomFactor - 0.5) * sidInfluencedDeviation; // Use SID-influenced deviation instead
  
  // Perpendicular direction to create the curved path
  const perpLat = -(end.lon - start.lon) * pathDeviation / directDistance;
  const perpLon = (end.lat - start.lat) * pathDeviation / directDistance;
  
  // Add start point
  waypoints.push({lat: start.lat, lon: start.lon});
  
  // For longer flights, add intermediate waypoints
  if (directDistance > 2) {
    const quarter = {
      lat: start.lat + (end.lat - start.lat) * 0.3 + perpLat * 0.4,
      lon: start.lon + (end.lon - start.lon) * 0.3 + perpLon * 0.4
    };
    
    const mid = {
      lat: midLat + perpLat,
      lon: midLon + perpLon
    };
    
    const threeQuarter = {
      lat: start.lat + (end.lat - start.lat) * 0.7 + perpLat * 0.4,
      lon: start.lon + (end.lon - start.lon) * 0.7 + perpLon * 0.4
    };
    
    waypoints.push(quarter);
    waypoints.push(mid);
    waypoints.push(threeQuarter);
  } else {
    // For shorter flights, just add mid waypoint
    waypoints.push({
      lat: midLat + perpLat * 0.5,
      lon: midLon + perpLon * 0.5
    });
  }
  
  // Add end point
  waypoints.push({lat: end.lat, lon: end.lon});
  
  // Create smooth path using Catmull-Rom splines for natural curves
  for (let i = 0; i < waypoints.length - 1; i++) {
    const startWP = waypoints[i];
    const endWP = waypoints[i+1];
    
    const pointsForSegment = Math.floor(numPoints / (waypoints.length - 1));
    
    for (let j = 0; j < pointsForSegment; j++) {
      const t = j / pointsForSegment;
      
      // Use simpler interpolation for better performance
      const lat = startWP.lat + (endWP.lat - startWP.lat) * t;
      const lon = startWP.lon + (endWP.lon - startWP.lon) * t;
      
      // Add minimal micro-variations for realism
      const microVariation = Math.sin(t * Math.PI * 2 + seedVal) * 0.0002; // Much smaller
      
      pathPoints.push({ 
        lat: lat + microVariation, 
        lon: lon + microVariation * 0.5 
      });
    }
  }
  
  // Ensure the exact end point is included
  pathPoints.push({ lat: end.lat, lon: end.lon });
  
  // Calculate realistic initial progress (small randomization)
  const progress = Math.random() * 0.05; // Reduced from 0.1 to 0.05
  
  // Determine cardinal direction based on overall heading
  const overallHeading = calculateHeading(start.lat, start.lon, end.lat, end.lon);
  let direction;
  
  if (overallHeading >= 315 || overallHeading < 45) direction = 'Eastbound';
  else if (overallHeading >= 45 && overallHeading < 135) direction = 'Northbound';
  else if (overallHeading >= 135 && overallHeading < 225) direction = 'Westbound';
  else direction = 'Southbound';
  
  // Calculate realistic flight duration based on actual distance
  const distanceNM = calculateDistanceNM(start, end);
  
  // Determine realistic cruise speed based on route distance
  let cruiseSpeedKts;
  if (distanceNM < 200) {
    // Short regional flights - smaller aircraft
    cruiseSpeedKts = 350 + Math.random() * 70; // 350-420 knots
  } else if (distanceNM < 800) {
    // Medium range - 737/A320 types  
    cruiseSpeedKts = 420 + Math.random() * 60; // 420-480 knots
  } else {
    // Long range - wide body jets, capped realistically
    cruiseSpeedKts = Math.min(490, 450 + Math.random() * 50); // 450-490 knots (capped)
  }
  
  // Calculate flight duration: distance/speed * conversion factors
  // Add 20% for taxi, climb, descent phases
  const flightTimeHours = (distanceNM / cruiseSpeedKts) * 1.2;
  const plannedDuration = Math.max(300000, flightTimeHours * 3600 * 1000); // Minimum 5 minutes
  
  return {
    id,
    callsign: `${airline}${flightNumber}`,
    origin: start.code,
    destination: end.code,
    path: pathPoints,
    color,
    progress: 0, // Always start at 0 to prevent woosh effect
    direction: direction,
    actualStartTime: Date.now() + Math.random() * 60000, // Randomize start times
    plannedDuration: plannedDuration,
    // Store calculated values for later use
    distanceNM: distanceNM,
    cruiseSpeedKts: cruiseSpeedKts,
    // Reduce turbulence factor for smoother movement
    turbulence: Math.random() * 0.05, // Further reduced
    // Weather and wind conditions - minimal impact
    windFactor: (Math.random() * 0.05) - 0.025, // Very small wind effects
    // Create a seed for this flight to make its behavior deterministic yet unique
    seed: seedVal,
    // Add tracking for throttled updates
    lastHeadingUpdateTime: 0,
    lastProgress: undefined // For exponential smoothing
  };
}

// Generate flight data with more natural paths
function generateFlights() {
  const flights = [];
  const airlines = ['AI', 'IX', 'SG', 'UK', 'I5', 'G8', '6E', 'QP'];

  const majorHubs = [
    { code: "BLR", name: "Bangalore", lat: 13.1989, lon: 77.7068 },
    { code: "DEL", name: "Delhi", lat: 28.5562, lon: 77.1000 },
    { code: "BOM", name: "Mumbai", lat: 19.0896, lon: 72.8656 },
    { code: "MAA", name: "Chennai", lat: 12.9941, lon: 80.1709 },
    { code: "HYD", name: "Hyderabad", lat: 17.2403, lon: 78.4294 },
    { code: "CCU", name: "Kolkata", lat: 22.6547, lon: 88.4467 }
  ];

  // Add local airports within visible region for more density
  const localAirports = [
    { code: "HAL", name: "HAL Bangalore", lat: 12.9500, lon: 77.6687 },
    { code: "JKD", name: "Jakkur Aerodrome", lat: 13.0820, lon: 77.5893 },
    { code: "YLK", name: "Yelahanka Air Base", lat: 13.1042, lon: 77.5958 },
    { code: "BWD", name: "Bidar Airstrip", lat: 13.0867, lon: 77.7200 },
    { code: "HSR", name: "Hosur Airstrip", lat: 12.7409, lon: 77.8315 },
    { code: "TBD", name: "Tumkur Airfield", lat: 13.2067, lon: 77.3500 },
    { code: "MVL", name: "Mandya Flying Club", lat: 12.8200, lon: 77.2800 },
    { code: "CHT", name: "Chitradurga Airstrip", lat: 13.1650, lon: 77.8100 },
    { code: "MLR", name: "Mallur Helipad", lat: 12.9300, lon: 77.2900 },
    { code: "ELC", name: "Electronic City Helipad", lat: 12.8458, lon: 77.6700 },
    { code: "WTF", name: "Whitefield Heliport", lat: 12.9698, lon: 77.7500 },
    { code: "YPR", name: "Yelahanka Police Air Wing", lat: 13.0950, lon: 77.5800 },
    { code: "DVN", name: "Devanahalli Training Strip", lat: 13.2400, lon: 77.7200 },
    { code: "KGR", name: "Kengeri Private Strip", lat: 12.9079, lon: 77.4850 }
  ];

  const regionalAirports = [
    { code: "CJB", name: "Coimbatore", lat: 11.0300, lon: 77.0434 },
    { code: "COK", name: "Cochin", lat: 10.1518, lon: 76.3930 },
    { code: "TRV", name: "Trivandrum", lat: 8.4833, lon: 76.9200 },
    { code: "MYQ", name: "Mysore", lat: 12.2300, lon: 76.6560 },
    { code: "IXE", name: "Mangalore", lat: 12.9614, lon: 74.8901 },
    { code: "PNQ", name: "Pune", lat: 18.5793, lon: 73.9089 },
    { code: "GOI", name: "Goa", lat: 15.3808, lon: 73.8314 },
    { code: "IXM", name: "Madurai", lat: 9.8343, lon: 78.0833 },
    { code: "CCJ", name: "Kozhikode", lat: 11.1356, lon: 75.9550 },
    { code: "IXB", name: "Bagdogra", lat: 26.6812, lon: 88.3287 },
    { code: "VGA", name: "Vijayawada", lat: 16.5266, lon: 80.7969 },
    { code: "IDR", name: "Indore", lat: 22.7220, lon: 75.8008 },
  ];

  const internationalAirports = [
    { code: "DXB", name: "Dubai", lat: 25.2532, lon: 55.3657 },
    { code: "SIN", name: "Singapore", lat: 1.3644, lon: 103.9915 },
    { code: "KUL", name: "Kuala Lumpur", lat: 2.7456, lon: 101.7099 },
    { code: "BKK", name: "Bangkok", lat: 13.6900, lon: 100.7501 },
    { code: "CMB", name: "Colombo", lat: 7.1808, lon: 79.8844 },
    { code: "DOH", name: "Doha", lat: 25.2609, lon: 51.6138 },
    { code: "AUH", name: "Abu Dhabi", lat: 24.4281, lon: 54.6511 },
    { code: "LHR", name: "London", lat: 51.4700, lon: -0.4543 }
  ];

  const edgePoints = [
    { code: "EDGE_NW", name: "Edge NW", lat: MAP_BOUNDS.north + 2, lon: MAP_BOUNDS.west - 2 },
    { code: "EDGE_NE", name: "Edge NE", lat: MAP_BOUNDS.north + 2, lon: MAP_BOUNDS.east + 2 },
    { code: "EDGE_SW", name: "Edge SW", lat: MAP_BOUNDS.south - 2, lon: MAP_BOUNDS.west - 2 },
    { code: "EDGE_SE", name: "Edge SE", lat: MAP_BOUNDS.south - 2, lon: MAP_BOUNDS.east + 2 },
    { code: "EDGE_N", name: "Edge N", lat: MAP_BOUNDS.north + 3, lon: (MAP_BOUNDS.west + MAP_BOUNDS.east) / 2 },
    { code: "EDGE_S", name: "Edge S", lat: MAP_BOUNDS.south - 3, lon: (MAP_BOUNDS.west + MAP_BOUNDS.east) / 2 },
    { code: "EDGE_E", name: "Edge E", lat: (MAP_BOUNDS.north + MAP_BOUNDS.south) / 2, lon: MAP_BOUNDS.east + 3 },
    { code: "EDGE_W", name: "Edge W", lat: (MAP_BOUNDS.north + MAP_BOUNDS.south) / 2, lon: MAP_BOUNDS.west - 3 },
  ];

  const allDestinations = [...majorHubs, ...regionalAirports];
  const visibleAirports = [...majorHubs, ...localAirports].filter(airport => {
    return airport.lon >= MAP_BOUNDS.west &&
           airport.lon <= MAP_BOUNDS.east &&
           airport.lat >= MAP_BOUNDS.south &&
           airport.lat <= MAP_BOUNDS.north;
  });
  
  let flightIdCounter = 0;

  // Generate more local flights within the visible region for higher density
  const numLocalFlights = 40; // Increased local flight density
  for (let i = 0; i < numLocalFlights; i++) {
    if (visibleAirports.length < 2) break;
    
    let origin = visibleAirports[Math.floor(Math.random() * visibleAirports.length)];
    let destination;
    
    // 60% chance to stay local, 40% chance to go to regional/major hub
    if (Math.random() < 0.6 && visibleAirports.length > 1) {
      do {
        destination = visibleAirports[Math.floor(Math.random() * visibleAirports.length)];
      } while (destination.code === origin.code);
    } else {
      destination = allDestinations[Math.floor(Math.random() * allDestinations.length)];
      if (destination.code === origin.code) {
        destination = regionalAirports[Math.floor(Math.random() * regionalAirports.length)];
      }
    }
    
    const airline = airlines[Math.floor(Math.random() * airlines.length)];
    const flightNumber = Math.floor(Math.random() * 9000) + 1000;
    const flight = createFlight(origin, destination, getRandomColor(flightIdCounter), `flight-${flightIdCounter++}`, airline, flightNumber);
    
    // NATURAL FLIGHT POSITIONING - flights start in realistic phases
    flight.progress = getRandomFlightProgress();
    flight.actualStartTime = Date.now() - (flight.progress * flight.plannedDuration) + (i * 250) + Math.random() * 8000; // Stagger starts
    flights.push(flight);
  }

  const numHubToHub = 15; // Slightly reduced
  for (let i = 0; i < numHubToHub; i++) {
    let origin = majorHubs[Math.floor(Math.random() * majorHubs.length)];
    let destination;
    do {
      destination = majorHubs[Math.floor(Math.random() * majorHubs.length)];
    } while (destination.code === origin.code);
    const airline = airlines[Math.floor(Math.random() * airlines.length)];
    const flightNumber = Math.floor(Math.random() * 9000) + 1000;
    const flight = createFlight(origin, destination, getRandomColor(flightIdCounter), `flight-${flightIdCounter++}`, airline, flightNumber);
    
    // Smooth initialization
    flight.progress = getRandomFlightProgress(); // NATURAL FLIGHT POSITIONING
    flight.actualStartTime = Date.now() - (flight.progress * flight.plannedDuration) + (i * 150) + Math.random() * 8000; // Stagger starts
    flights.push(flight);
  }

  const numHubSpoke = 25; // Slightly reduced
  for (let i = 0; i < numHubSpoke; i++) {
    let origin, destination;
    if (Math.random() < 0.5) { 
      origin = majorHubs[Math.floor(Math.random() * majorHubs.length)];
      destination = [...regionalAirports, ...localAirports, ...edgePoints][Math.floor(Math.random() * (regionalAirports.length + localAirports.length + edgePoints.length))];
    } else { 
      origin = [...regionalAirports, ...localAirports, ...edgePoints][Math.floor(Math.random() * (regionalAirports.length + localAirports.length + edgePoints.length))];
      destination = majorHubs[Math.floor(Math.random() * majorHubs.length)];
    }
    if (origin.code === destination.code) continue; 
    const airline = airlines[Math.floor(Math.random() * airlines.length)];
    const flightNumber = Math.floor(Math.random() * 9000) + 1000;
    const flight = createFlight(origin, destination, getRandomColor(flightIdCounter), `flight-${flightIdCounter++}`, airline, flightNumber);
    
    // Smooth initialization
    flight.progress = getRandomFlightProgress(); // NATURAL FLIGHT POSITIONING
    flight.actualStartTime = Date.now() - (flight.progress * flight.plannedDuration) + (i * 120) + Math.random() * 6000; // Stagger starts
    flights.push(flight);
  }
  
  const numRegionalToRegional = 20; // Slightly reduced
  for (let i = 0; i < numRegionalToRegional; i++) {
    let origin = regionalAirports[Math.floor(Math.random() * regionalAirports.length)];
    let destination;
    do {
      destination = regionalAirports[Math.floor(Math.random() * regionalAirports.length)];
    } while (destination.code === origin.code);
    const airline = airlines[Math.floor(Math.random() * airlines.length)];
    const flightNumber = Math.floor(Math.random() * 9000) + 1000;
    const flight = createFlight(origin, destination, getRandomColor(flightIdCounter), `flight-${flightIdCounter++}`, airline, flightNumber);
    
    // Smooth initialization
    flight.progress = getRandomFlightProgress(); // NATURAL FLIGHT POSITIONING
    flight.actualStartTime = Date.now() - (flight.progress * flight.plannedDuration) + (i * 200) + Math.random() * 10000; // Stagger starts
    flights.push(flight);
  }
  
  // Add international flights
  const numInternational = 15; // Slightly reduced
  for (let i = 0; i < numInternational; i++) {
    const isOutbound = Math.random() > 0.5;
    let origin, destination;
    
    if (isOutbound) {
      origin = majorHubs[Math.floor(Math.random() * majorHubs.length)];
      destination = internationalAirports[Math.floor(Math.random() * internationalAirports.length)];
    } else {
      origin = internationalAirports[Math.floor(Math.random() * internationalAirports.length)];
      destination = majorHubs[Math.floor(Math.random() * majorHubs.length)];
    }
    
    const airline = airlines[Math.floor(Math.random() * airlines.length)];
    const flightNumber = Math.floor(Math.random() * 9000) + 1000;
    const flight = createFlight(origin, destination, getRandomColor(flightIdCounter), `flight-${flightIdCounter++}`, airline, flightNumber);
    
    // Smooth initialization
    flight.progress = getRandomFlightProgress(); // NATURAL FLIGHT POSITIONING
    flight.actualStartTime = Date.now() - (flight.progress * flight.plannedDuration) + (i * 300) + Math.random() * 12000; // Stagger starts
    flights.push(flight);
  }
  
  const numEdgeIncoming = 15; // Same
  for (let i = 0; i < numEdgeIncoming; i++) {
    let origin = edgePoints[Math.floor(Math.random() * edgePoints.length)];
    let destination = [...allDestinations, ...localAirports][Math.floor(Math.random() * (allDestinations.length + localAirports.length))];
    const airline = airlines[Math.floor(Math.random() * airlines.length)];
    const flightNumber = Math.floor(Math.random() * 9000) + 1000;
    const flight = createFlight(origin, destination, getRandomColor(flightIdCounter), `flight-${flightIdCounter++}`, airline, flightNumber);
    
    // Smooth initialization
    flight.progress = getRandomFlightProgress(); // NATURAL FLIGHT POSITIONING
    flight.actualStartTime = Date.now() - (flight.progress * flight.plannedDuration) + (i * 250) + Math.random() * 8000; // Stagger starts
    flights.push(flight);
  }

  const numEdgeOutgoing = 15; // Same
  for (let i = 0; i < numEdgeOutgoing; i++) {
    let origin = [...allDestinations, ...localAirports][Math.floor(Math.random() * (allDestinations.length + localAirports.length))];
    let destination = edgePoints[Math.floor(Math.random() * edgePoints.length)];
    const airline = airlines[Math.floor(Math.random() * airlines.length)];
    const flightNumber = Math.floor(Math.random() * 9000) + 1000;
    const flight = createFlight(origin, destination, getRandomColor(flightIdCounter), `flight-${flightIdCounter++}`, airline, flightNumber);
    
    // Smooth initialization
    flight.progress = getRandomFlightProgress(); // NATURAL FLIGHT POSITIONING
    flight.actualStartTime = Date.now() - (flight.progress * flight.plannedDuration) + (i * 280) + Math.random() * 9000; // Stagger starts
    flights.push(flight);
  }
  
  console.log(`Generated ${flights.length} flights with ${visibleAirports.length} airports visible in frame.`);
  return flights;
}

// Get a random initial flight progress based on a realistic distribution
function getRandomFlightProgress() {
  const rand = Math.random();
  
  // 30% chance of being at airport/early climb (0-15%)
  if (rand < 0.3) {
    return Math.random() * 0.15;
  }
  // 50% chance of being in cruise phase (15-85%)
  else if (rand < 0.8) {
    return 0.15 + Math.random() * 0.7;
  }
  // 20% chance of being in descent/landing (85-100%)
  else {
    return 0.85 + Math.random() * 0.15;
  }
}

// Get a random pastel color
function hexToRgba(hex, alpha = 0.5) {
  // strip leading "#" and expand shorthand (#abc → #aabbcc)
  const h = hex.replace('#', '');
  const bigint = h.length === 3
    ? parseInt(h.split('').map(c => c + c).join(''), 16)
    : parseInt(h, 16);

  const r = (bigint >> 16) & 255;
  const g = (bigint >>  8) & 255;
  const b =  bigint        & 255;

  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function getRandomColor(index, alpha = 0.5) {
  const accessibleColors = [
    '#0072B2', // blue
    '#E69F00', // orange
    '#009E73', // green
    '#CC79A7', // magenta
    '#56B4E9', // sky blue
    '#D55E00', // red-orange
    '#F0E442', // yellow
    '#6d2dac'  // deep purple
  ];
  return hexToRgba(accessibleColors[index % accessibleColors.length], alpha);
}

// Create a plane marker using Leaflet
function createPlaneMarker(flight) {
  if (!leafletMap) return null;
  
  const initialPoint = flight.path[0];
  let initialAngle = 0;
  if (flight.path.length > 1) {
    const secondPoint = flight.path[1];
    initialAngle = calculateHeading(initialPoint.lat, initialPoint.lon, secondPoint.lat, secondPoint.lon);
  }
  
  // Create a plane icon using asterisk
  const planeIcon = L.divIcon({
    className: 'plane-marker',
    html: `<div class="plane-icon" style="transform: rotate(${initialAngle - 90}deg); color: #3239be;">*</div>`,
    iconSize: [24, 24],
    iconAnchor: [12, 12]
  });
  
  // Create the marker
  const marker = L.marker([initialPoint.lat, initialPoint.lon], { 
    icon: planeIcon,
    zIndexOffset: 1000 // Ensure planes appear above other elements
  }).addTo(leafletMap);
  
  // Store flight data on the marker
  marker.flightData = {
    id: flight.id,
    callsign: flight.callsign,
    origin: flight.origin,
    destination: flight.destination
  };
  
  // Add click event for following
  marker.on('click', function(e) {
    e.originalEvent.stopPropagation();
    
    // Clear all existing highlights
    clearAllHighlights();
    
    // If already following this flight, stop following
    if (followingEnabled && followingFlight && followingFlight.id === flight.id) {
      stopFollowingFlight();
      return;
    }
    
    // Start following this flight
    startFollowingFlight(flight);
    
    // Highlight this marker
    marker.getElement().classList.add('highlighted');
    
    // Find and highlight the corresponding flight card
    const flightCard = document.getElementById(`card-${flight.id}`);
    if (flightCard) {
      flightCard.classList.add('selected');
      flightCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  });
  
  // Add hover events for tooltip
  marker.on('mouseover', function(e) {
    showTooltipForMarker(marker, flight);
  });
  
  marker.on('mouseout', function(e) {
    hideTooltipDelayed();
  });
  
  return marker;
}

// Create a plane element
function createPlane(flight) {
  const map = document.getElementById('flight-map');
  const plane = document.createElement('div');
  plane.id = flight.id;
  plane.className = 'plane';
  plane.textContent = '*'; // Use asterisk symbol
  
  plane.dataset.callsign = flight.callsign;
  plane.dataset.origin = flight.origin;
  plane.dataset.destination = flight.destination;
  
  const initialPoint = flight.path[0];
  let initialAngle = 0;
  if (flight.path.length > 1) {
    const secondPoint = flight.path[1];
    initialAngle = calculateHeading(initialPoint.lat, initialPoint.lon, secondPoint.lat, secondPoint.lon);
  }
  
  // Apply a -90 degree offset because the asterisk '*' visually points up by default
  // Our calculateHeading now gives 0 for East. To make asterisk point East, rotate -90 deg.
  plane.style.transform = `translate(-50%, -50%) rotate(${initialAngle - 90}deg)`;
  
  const pixelPos = coordsToPixels(initialPoint.lat, initialPoint.lon);
  plane.style.left = pixelPos.x + 'px';
  plane.style.top = pixelPos.y + 'px';
  
  plane.addEventListener('mouseenter', showTooltip);
  plane.addEventListener('mouseleave', hideTooltipDelayed);
  
  // Add additional safety event to hide tooltip
  plane.addEventListener('mouseout', hideTooltipDelayed);
  
  // Add click event to highlight the plane and its flight card
  plane.addEventListener('click', function(event) {
    event.stopPropagation(); // Prevent map click from clearing selection
    
    // Clear all existing highlights
    clearAllHighlights();
    
    // If already following this flight, stop following
    if (followingEnabled && followingFlight && followingFlight.id === flight.id) {
      stopFollowingFlight();
      return;
    }
    
    // Start following this flight
    startFollowingFlight(flight);
    
    // Highlight this plane
    plane.classList.add('highlighted');
    
    // Create pulsing highlight effect
    createPulsingHighlight(plane, flight);
    
    // Find and highlight the corresponding flight card
    const flightCard = document.getElementById(`card-${flight.id}`);
    if (flightCard) {
      flightCard.classList.add('selected');
      flightCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  });
  
  map.appendChild(plane);
  return plane;
}

// Create a canvas for drawing the flight path
function createPathCanvas(flight) {
  const map = document.getElementById('flight-map');
  const mapContainer = document.getElementById('map-container');
  
  // Create canvas for the flight path
  const canvas = document.createElement('canvas');
  
  // Use actual container dimensions
  if (mapContainer) {
    const containerRect = mapContainer.getBoundingClientRect();
    canvas.width = containerRect.width;
    canvas.height = containerRect.height;
  } else {
    canvas.width = MAP_WIDTH;
    canvas.height = MAP_HEIGHT;
  }
  
  canvas.className = 'path';
  canvas.id = `path-${flight.id}`;
  
  map.appendChild(canvas);
  return canvas;
}

// Draw the flight path with trailing effect
function drawFlightPath(canvas, flight, progress) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Calculate the visible portion of the path (trailing effect)
  let trailLength = 0.24; // Base trail length
  
  // INCREASE trail length and opacity when following this flight
  const isFollowing = followingEnabled && followingFlight && followingFlight.id === flight.id;
  if (isFollowing) {
    trailLength = 0.45; // Much longer trail when following
  }
  
  const startProgress = Math.max(0, progress - trailLength);
  
  // Find the start and end indices in the path array
  const startIdx = Math.floor(startProgress * (flight.path.length - 1));
  const endIdx = Math.floor(progress * (flight.path.length - 1));
  
  if (endIdx <= startIdx) return;
  
  // Draw the path with improved visibility and dynamic opacity
  ctx.beginPath();
  ctx.strokeStyle = flight.color;
  
  if (isFollowing) {
    // MUCH more visible when following
    ctx.lineWidth = 3.5; // Thicker line when following
    ctx.setLineDash([6, 6]); // More solid dashes when following
    // Increase opacity for following mode
    const baseColor = flight.color.replace(/rgba?\([^)]+\)/, '');
    const colorMatch = flight.color.match(/rgba?\(([^)]+)\)/);
    if (colorMatch) {
      const [r, g, b] = colorMatch[1].split(',').map(n => parseInt(n.trim()));
      ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.9)`; // High opacity when following
    }
  } else {
    // Standard visibility for non-followed flights
    ctx.lineWidth = 2.5; // Slightly increased from 2.0
    ctx.setLineDash([4, 8]); // Standard dashes
    // Slightly increase base opacity
    const baseColor = flight.color.replace(/rgba?\([^)]+\)/, '');
    const colorMatch = flight.color.match(/rgba?\(([^)]+)\)/);
    if (colorMatch) {
      const [r, g, b] = colorMatch[1].split(',').map(n => parseInt(n.trim()));
      ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.7)`; // Increased from default
    }
  }
  
  // Start point
  const startPoint = flight.path[startIdx];
  const startPixels = coordsToPixels(startPoint.lat, startPoint.lon);
  ctx.moveTo(startPixels.x, startPixels.y);
  
  // Draw line through all points in between
  for (let i = startIdx + 1; i <= endIdx; i++) {
    const point = flight.path[i];
    const pixels = coordsToPixels(point.lat, point.lon);
    ctx.lineTo(pixels.x, pixels.y);
  }
  
  ctx.stroke();
}

// Create a flight card in the sidebar with more realistic data
function createFlightCard(flight, flightInfo) {
  const { altitude, groundSpeed, heading, verticalSpeed, turbulence } = flightInfo;
  
  const card = document.createElement('div');
  card.className = 'flight-card';
  card.id = `card-${flight.id}`;
  
  // Get the color for the left border (without alpha transparency)
  const solidColor = flight.color.replace('rgba', 'rgb').replace(/, [0-9.]+\)/, ')');
  
  const colorIndicator = document.createElement('div');
  colorIndicator.className = 'color-indicator';
  colorIndicator.style.backgroundColor = solidColor;
  card.appendChild(colorIndicator);
  
  const content = document.createElement('div');
  content.className = 'flight-card-content';
  
  // Flight callsign with proper airline formatting
  const callsign = document.createElement('div');
  callsign.className = 'flight-number';
  callsign.textContent = flight.callsign;
  content.appendChild(callsign);
  
  // Flight route with ICAO codes
  const route = document.createElement('div');
  route.className = 'flight-route';
  route.textContent = `${flight.origin} → ${flight.destination}`;
  content.appendChild(route);
  
  // Simple layout using the original style with fixed width values
  const detailsContainer = document.createElement('div');
  detailsContainer.style.marginTop = '6px';
  
  // Altitude detail
  const altDetail = document.createElement('div');
  altDetail.className = 'flight-detail';
  
  const altLabel = document.createElement('span');
  altLabel.textContent = 'ALT:';
  altLabel.style.marginRight = '4px';
  
  const altValue = document.createElement('span');
  altValue.className = 'alt-value';
  altValue.textContent = `${altitude.toLocaleString()} ft`;
  
  altDetail.appendChild(altLabel);
  altDetail.appendChild(altValue);
  detailsContainer.appendChild(altDetail);
  
  // Speed detail
  const spdDetail = document.createElement('div');
  spdDetail.className = 'flight-detail';
  
  const spdLabel = document.createElement('span');
  spdLabel.textContent = 'SPD:';
  spdLabel.style.marginRight = '4px';
  
  const spdValue = document.createElement('span');
  spdValue.className = 'spd-value';
  spdValue.textContent = `${groundSpeed} kts`;
  
  spdDetail.appendChild(spdLabel);
  spdDetail.appendChild(spdValue);
  detailsContainer.appendChild(spdDetail);
  
  // Heading detail
  const hdgDetail = document.createElement('div');
  hdgDetail.className = 'flight-detail';
  
  const hdgLabel = document.createElement('span');
  hdgLabel.textContent = 'HDG:';
  hdgLabel.style.marginRight = '4px';
  
  const hdgValue = document.createElement('span');
  hdgValue.className = 'hdg-value';
  // Format heading with leading zeros
  const formattedHeading = heading.toString().padStart(3, '0');
  hdgValue.textContent = `${formattedHeading}°`;
  
  hdgDetail.appendChild(hdgLabel);
  hdgDetail.appendChild(hdgValue);
  detailsContainer.appendChild(hdgDetail);
  
  // Vertical speed detail (optional)
  if (verticalSpeed !== 0) {
    const vsDetail = document.createElement('div');
    vsDetail.className = 'flight-detail';
    
    const vsLabel = document.createElement('span');
    vsLabel.textContent = 'V/S:';
    vsLabel.style.marginRight = '4px';
    
    const vsValue = document.createElement('span');
    vsValue.className = 'vs-value';
    // Format vertical speed with sign and fpm
    const vsSign = verticalSpeed > 0 ? '+' : '';
    vsValue.textContent = `${vsSign}${verticalSpeed} fpm`;
    
    vsDetail.appendChild(vsLabel);
    vsDetail.appendChild(vsValue);
    detailsContainer.appendChild(vsDetail);
  }
  
  content.appendChild(detailsContainer);
  
  // Add turbulence indicator if not smooth
  if (turbulence !== 'Smooth') {
    const turbDetail = document.createElement('div');
    turbDetail.className = 'turbulence-indicator';
    turbDetail.style.marginTop = '4px';
    turbDetail.style.fontSize = '11px';
    turbDetail.style.color = turbulence === 'Moderate' ? '#ffcc00' : '#a9a9a9';
    turbDetail.textContent = `${turbulence} Turbulence`;
    content.appendChild(turbDetail);
  }
  
  card.appendChild(content);
  
  // Add click event to highlight the plane on the map
  card.addEventListener('click', function() {
    // First, remove highlight from all planes
    clearAllHighlights();
    
    // If already following this flight, stop following
    if (followingEnabled && followingFlight && followingFlight.id === flight.id) {
      stopFollowingFlight();
      return;
    }
    
    // Start following this flight
    startFollowingFlight(flight);
    
    // Then, highlight this plane
    highlightPlane(flight.id);
    
    // Add selected class to this card
    this.classList.add('selected');
  });
  
  return card;
}

// Function to clear all highlights from planes
function clearAllHighlights() {
  // Remove selected class from all flight cards
  document.querySelectorAll('.flight-card.selected').forEach(card => {
    card.classList.remove('selected');
  });
  
  // Remove highlight class from all visible planes (DOM elements)
  document.querySelectorAll('.plane.highlighted').forEach(plane => {
    plane.classList.remove('highlighted');
  });
  
  // Remove highlight class from all Leaflet markers
  Object.values(leafletMarkers).forEach(marker => {
    if (marker && marker.getElement()) {
      marker.getElement().classList.remove('highlighted');
    }
  });
  
  // Remove any pulsing highlight effect
  const highlight = document.getElementById('pulsing-highlight');
  if (highlight) {
    highlight.remove();
  }
  
  // Stop following if active
  if (followingEnabled) {
    stopFollowingFlight();
  }
}

// Function to highlight a specific plane
function highlightPlane(flightId) {
  const plane = document.getElementById(flightId);
  if (plane) {
    // Add highlight class
    plane.classList.add('highlighted');
    
    // Ensure the plane is visible in the viewport
    plane.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
    
    // Find the flight object for color information
    const flight = flightData.find(f => f.id === flightId);
    
    // Create a pulsing highlight effect
    createPulsingHighlight(plane, flight);
  }
}

// Function to create a pulsing highlight effect using flight's own color
function createPulsingHighlight(plane, flight) {
  // Remove any existing highlight animation
  const existingHighlight = document.getElementById('pulsing-highlight');
  if (existingHighlight) {
    existingHighlight.remove();
  }
  
  // Extract RGB values from flight color for the highlight
  let highlightColor = 'rgba(255, 255, 255, 0.7)'; // Fallback to white
  let shadowColor = 'rgba(255, 255, 255, 0)'; // Fallback shadow
  
  if (flight && flight.color) {
    const colorMatch = flight.color.match(/rgba?\(([^)]+)\)/);
    if (colorMatch) {
      const [r, g, b] = colorMatch[1].split(',').map(n => parseInt(n.trim()));
      highlightColor = `rgba(${r}, ${g}, ${b}, 0.8)`; // Bright version of flight color
      shadowColor = `rgba(${r}, ${g}, ${b}, 0)`; // Transparent shadow for animation
    }
  }
  
  // Create a pulsing circle around the plane
  const highlight = document.createElement('div');
  highlight.id = 'pulsing-highlight';
  highlight.style.position = 'absolute';
  highlight.style.width = '30px';
  highlight.style.height = '30px';
  highlight.style.borderRadius = '50%';
  highlight.style.border = `2px solid ${highlightColor}`;
  highlight.style.transform = 'translate(-50%, -50%)';
  highlight.style.left = plane.style.left;
  highlight.style.top = plane.style.top;
  highlight.style.animation = 'pulse-colored 1.5s infinite';
  highlight.style.pointerEvents = 'none'; // Don't interfere with mouse events
  highlight.style.zIndex = '1000';
  
  // Add the highlight to the map
  document.getElementById('flight-map').appendChild(highlight);
  
  // Create/update the CSS animation with flight color
  const existingStyle = document.getElementById('pulse-animation');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  const style = document.createElement('style');
  style.id = 'pulse-animation';
  style.textContent = `
    @keyframes pulse-colored {
      0% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
        box-shadow: 0 0 0 0 ${highlightColor};
      }
      70% {
        transform: translate(-50%, -50%) scale(2.2);
        opacity: 0;
        box-shadow: 0 0 0 15px ${shadowColor};
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
      }
    }
  `;
  document.head.appendChild(style);
}

// Update an existing flight card with new data
function updateFlightCardIfDisplayed(flight, flightInfo) {
  const card = document.getElementById(`card-${flight.id}`);
  if (card) {
    const altElement = card.querySelector('.alt-value');
    const spdElement = card.querySelector('.spd-value');
    const hdgElement = card.querySelector('.hdg-value');
    const vsElement = card.querySelector('.vs-value');
    
    if (altElement) altElement.textContent = `${flightInfo.altitude.toLocaleString()} ft`;
    if (spdElement) spdElement.textContent = `${flightInfo.groundSpeed} kts`;
    
    if (hdgElement) {
      // Format heading with leading zeros
      const formattedHeading = flightInfo.heading.toString().padStart(3, '0');
      hdgElement.textContent = `${formattedHeading}°`;
    }
    
    if (vsElement) {
      // Format vertical speed with sign
      const vsSign = flightInfo.verticalSpeed > 0 ? '+' : '';
      vsElement.textContent = `${vsSign}${flightInfo.verticalSpeed} fpm`;
    }
    
    // Update turbulence indicator if exists
    const turbElement = card.querySelector('.turbulence-indicator');
    if (turbElement) {
      if (flightInfo.turbulence === 'Smooth') {
        turbElement.style.display = 'none';
      } else {
        turbElement.style.display = 'block';
        turbElement.textContent = `${flightInfo.turbulence} Turbulence`;
        turbElement.style.color = flightInfo.turbulence === 'Moderate' ? '#ffcc00' : '#a9a9a9';
      }
    }
    
    // Update highlight position if this card is selected
    if (card.classList.contains('selected')) {
      const plane = document.getElementById(flight.id);
      const highlight = document.getElementById('pulsing-highlight');
      if (plane && highlight) {
        highlight.style.left = plane.style.left;
        highlight.style.top = plane.style.top;
      }
    }
  }
}

// Check if a flight's current position is within the visible map bounds
function isFlightVisible(flight, progress) {
  const exactIndex = progress * (flight.path.length - 1);
  const index = Math.floor(exactIndex);
  const nextIndex = Math.min(index + 1, flight.path.length - 1);
  const t = exactIndex - index;
  
  const currentPoint = flight.path[index];
  const nextPoint = flight.path[nextIndex];
  
  // Interpolate current position
  const currentLat = currentPoint.lat + (nextPoint.lat - currentPoint.lat) * t;
  const currentLon = currentPoint.lon + (nextPoint.lon - currentPoint.lon) * t;
  
  // Check if position is within visible bounds
  return currentLat >= MAP_BOUNDS.south && 
         currentLat <= MAP_BOUNDS.north && 
         currentLon >= MAP_BOUNDS.west && 
         currentLon <= MAP_BOUNDS.east;
}

// Get all currently visible flights
function getVisibleFlights() {
  const now = Date.now();
  const visibleFlights = [];
  
  flightData.forEach(flight => {
    // Calculate current progress
    const elapsedTime = now - flight.actualStartTime;
    const progress = Math.min(1, Math.max(0, elapsedTime / flight.plannedDuration));
    
    // Only include if flight is visible and not completed
    if (progress < 1 && isFlightVisible(flight, progress)) {
      // Calculate flight info for sorting
      const flightInfo = calculateFlightInfo(flight, progress);
      visibleFlights.push({
        flight,
        flightInfo,
        progress,
        timestamp: Date.now()
      });
    }
  });
  
  // Sort by progress to show flights in a consistent order
  return visibleFlights.sort((a, b) => a.progress - b.progress);
}

// Initialize permanent flights in the sidebar
function initializeRecentFlights() {
  // Clear any existing flight cards
  const container = document.querySelector('.flights-container');
  container.innerHTML = '';
  
  // Get only visible flights
  const visibleFlights = getVisibleFlights();
  
  // Update recent flights storage
  recentFlights = visibleFlights;
  
  // Calculate the total number of pages based on visible flights
  const totalPages = Math.ceil(visibleFlights.length / flightsPerPage);
  
  // Ensure current page is valid
  if (currentPage >= totalPages && totalPages > 0) {
    currentPage = Math.max(0, totalPages - 1);
  }
  
  // Get the flights for the current page
  const startIndex = currentPage * flightsPerPage;
  const displayFlights = visibleFlights.slice(startIndex, startIndex + flightsPerPage);
  
  // Display the selected flights in the sidebar
  displayFlights.forEach(flightData => {
    // Create and add the card
    const card = createFlightCard(flightData.flight, flightData.flightInfo);
    container.appendChild(card);
  });
  
  // Add pagination controls
  addPaginationControls(container, totalPages);
  
  console.log(`Displaying ${displayFlights.length} visible flights out of ${visibleFlights.length} total visible flights`);
}

// Add pagination controls
function addPaginationControls(container, totalPages) {
  // Remove any existing pagination controls first
  const existingControls = document.querySelector('.pagination-controls');
  if (existingControls) {
    existingControls.remove();
  }
  
  // Create pagination container
  const paginationDiv = document.createElement('div');
  paginationDiv.className = 'pagination-controls';
  
  // Add previous button
  const prevButton = document.createElement('button');
  prevButton.className = 'pagination-button';
  prevButton.innerHTML = '&larr;';
  prevButton.disabled = currentPage === 0;
  prevButton.addEventListener('click', () => {
    if (currentPage > 0) {
      currentPage--;
      refreshFlightList();
    }
  });
  
  // Add page indicator
  const pageIndicator = document.createElement('span');
  pageIndicator.className = 'page-indicator';
  pageIndicator.textContent = `${currentPage + 1}/${totalPages}`;
  
  // Add next button
  const nextButton = document.createElement('button');
  nextButton.className = 'pagination-button';
  nextButton.innerHTML = '&rarr;';
  nextButton.disabled = currentPage >= totalPages - 1;
  nextButton.addEventListener('click', () => {
    if (currentPage < totalPages - 1) {
      currentPage++;
      refreshFlightList();
    }
  });
  
  // Add elements to pagination container
  paginationDiv.appendChild(prevButton);
  paginationDiv.appendChild(pageIndicator);
  paginationDiv.appendChild(nextButton);
  
  // Find the sidebar content div
  const sidebarContent = document.querySelector('.sidebar-content');
  sidebarContent.appendChild(paginationDiv);
}

// Refresh flight list to show current page
function refreshFlightList() {
  // Re-initialize with current page
  initializeRecentFlights();
}

// Animation loop with more realistic flight behavior
function animateFlights() {
  // Get current timestamp for calculations
  const now = Date.now();
  
  // Handle initialization phase
  if (isInitializing) {
    if (initializationStartTime === 0) {
      initializationStartTime = now;
    }
    
    const initElapsed = now - initializationStartTime;
    const initProgress = Math.min(1, initElapsed / initializationDuration);
    
    // Update loading progress
    updateLoadingProgress(initProgress);
    
    // End initialization phase after duration
    if (initProgress >= 1) {
      isInitializing = false;
      hideLoadingOverlay();
      console.log("Initialization complete - normal animation speed");
    }
  }
  
  // Update sidebar every 5 seconds to remove out-of-bounds flights
  if (now - lastSidebarUpdate > 5000) { // 5 seconds
    initializeRecentFlights();
    lastSidebarUpdate = now;
  }
  
  // Process completed flights for return journeys every 10 seconds
  if (now - (window.lastReturnFlightCheck || 0) > 10000) {
    processCompletedFlights();
    window.lastReturnFlightCheck = now;
    
    // Log flight statistics
    const stats = getFlightHistoryStats();
    console.log(`📊 Flight Stats - Active: ${stats.activeFlights}, Completed: ${stats.totalCompleted}, Returns: ${stats.returnFlights}`);
  }
  
  // Update each flight
  flightData.forEach(flight => {
    // Calculate real flight progress based on elapsed time since flight start
    // This makes flights move at different speeds based on their planned duration
    const elapsedTime = now - flight.actualStartTime;
    let normalizedProgress = Math.min(1, Math.max(0, elapsedTime / flight.plannedDuration));
    
    // During initialization, slow down animation and apply fade-in
    if (isInitializing) {
      const initElapsed = now - initializationStartTime;
      const initProgress = Math.min(1, initElapsed / initializationDuration);
      
      // Slow down animation during initialization more gradually
      normalizedProgress *= (0.5 + 0.5 * initProgress); // Start at 50% speed, ramp to 100%
    }
    
    // Apply very minimal wind effects to progress
    let adjustedProgress = normalizedProgress * (1 + flight.windFactor * 0.1); // Much smaller wind impact
    
    // Make sure progress is between 0-1 and add smoothing to prevent jumps
    adjustedProgress = Math.min(1, Math.max(0, adjustedProgress));
    
    // Apply exponential smoothing to prevent jerky motion
    const alpha = 0.1; // smoothing factor
    const smoothedProgress = flight.lastProgress !== undefined 
      ? flight.lastProgress + alpha * (adjustedProgress - flight.lastProgress)
      : adjustedProgress;
    
    // Update last progress for next frame
    flight.lastProgress = smoothedProgress;
    
    // Use smoothed progress for all calculations
    adjustedProgress = smoothedProgress;
    
    // Get current path segment
    const totalPathPoints = flight.path.length - 1;
    const exactIndex = adjustedProgress * totalPathPoints;
    const currentIndex = Math.floor(exactIndex);
    const nextIndex = Math.min(currentIndex + 1, totalPathPoints);
    const segmentProgress = exactIndex - currentIndex;
    
    // Current position data
    const currentPoint = flight.path[currentIndex];
    const nextPoint = flight.path[nextIndex];
    
    // Get the plane and path elements
    const plane = planeDivs[flight.id];
    const leafletMarker = leafletMarkers[flight.id];
    const pathCanvas = pathCanvases[flight.id];
    
    if (!pathCanvas) return;
    
    // Check if flight is visible in current bounds
    const isVisible = isFlightVisibleInCurrentView(flight, adjustedProgress);
    
    // Calculate fade-in opacity during initialization
    let opacity = 1;
    if (isInitializing) {
      const initElapsed = now - initializationStartTime;
      const initProgress = Math.min(1, initElapsed / initializationDuration);
      
      // Only show flights that have started (based on their staggered start times)
      if (elapsedTime < 0) {
        opacity = 0; // Flight hasn't started yet
      } else {
        // Fade in over 1 second after flight starts
        const fadeInDuration = 1000;
        const fadeProgress = Math.min(1, elapsedTime / fadeInDuration);
        opacity = fadeProgress * (0.3 + 0.7 * initProgress); // Gradually increase max opacity
      }
    }
    
    // Hide/show plane and path based on visibility
    if (isVisible && opacity > 0) {
      // Hide DOM plane since we're using Leaflet markers
      if (plane) plane.style.display = 'none';
      
      // Show and update Leaflet marker
      if (leafletMarker) {
        leafletMarker.setOpacity(opacity * 0.7); // Apply initialization fade
        
        // Use great circle interpolation for current position
        const interpolatedPos = interpolateGreatCircle(
          currentPoint.lat, currentPoint.lon,
          nextPoint.lat, nextPoint.lon,
          segmentProgress
        );
        
        // Update marker position
        leafletMarker.setLatLng([interpolatedPos.lat, interpolatedPos.lon]);
        
        // Calculate and throttle rotation updates to reduce flickering
        let heading = 0;
        if (currentPoint && nextPoint) {
          heading = Math.round(calculateHeading(currentPoint.lat, currentPoint.lon, nextPoint.lat, nextPoint.lon));
        }
        
        // Throttle heading updates to every 300ms to reduce visual noise
        if (!flight.lastHeadingUpdateTime || now - flight.lastHeadingUpdateTime > 300) {
          updateLeafletRotation(leafletMarker, heading);
          flight.lastHeadingUpdateTime = now;
        }
      }
      
      pathCanvas.style.display = 'block';
      pathCanvas.style.opacity = opacity;
      
      // Calculate realistic flight info based on progress, position and heading
      const flightInfo = calculateFlightInfo(flight, adjustedProgress, currentPoint, nextPoint, segmentProgress);
      
      // Update flight path with current progress
      drawFlightPath(pathCanvas, flight, adjustedProgress);
      
      // Update camera if following this flight
      updateFollowingCamera(flight, adjustedProgress);
      
      // Update the flight card if it exists
      updateFlightCardIfDisplayed(flight, flightInfo);
      
      // Update following detail view if active
      updateFollowingDetailView(flight, adjustedProgress, flightInfo);
    } else {
      // Hide plane and path when out of bounds or not visible
      if (plane) plane.style.display = 'none';
      if (leafletMarker) leafletMarker.setOpacity(0);
      pathCanvas.style.display = 'none';
      
      // Stop following if this flight goes out of bounds
      if (followingEnabled && followingFlight && followingFlight.id === flight.id) {
        stopFollowingFlight();
        clearAllHighlights();
      }
    }
    
    // If flight has completed and recycling is needed
    if (adjustedProgress >= 1) {
      // Check if this flight has already been processed for completion
      if (!completedFlightIds.has(flight.id)) {
        // This will be handled by processCompletedFlights()
        return;
      }
      
      // For flights that have been processed, check if they should be recycled or removed
      if (flight.isReturnFlight) {
        // Return flights don't spawn new returns - just recycle normally
        flight.progress = getRandomFlightProgress();
        flight.lastProgress = undefined;
        flight.actualStartTime = now + Math.random() * 60000; // Start again after 0-60 seconds
        
        // Recalculate realistic duration
        if (flight.distanceNM && flight.cruiseSpeedKts) {
          const flightTimeHours = (flight.distanceNM / flight.cruiseSpeedKts) * 1.2;
          flight.plannedDuration = Math.max(300000, flightTimeHours * 3600 * 1000);
        }
        
        flight.windFactor = (Math.random() * 0.05) - 0.025;
        flight.turbulence = Math.random() * 0.05;
        flight.lastHeadingUpdateTime = 0;
      } else {
        // Original flights that have been processed - recycle with new random factors
        flight.progress = getRandomFlightProgress();
        flight.lastProgress = undefined;
        flight.actualStartTime = now + Math.random() * 30000; // Start again after 0-30 seconds
        
        // Remove from completed set so it can potentially generate returns again
        completedFlightIds.delete(flight.id);
        
        // Recalculate realistic duration
        if (flight.distanceNM && flight.cruiseSpeedKts) {
          const flightTimeHours = (flight.distanceNM / flight.cruiseSpeedKts) * 1.2;
          flight.plannedDuration = Math.max(300000, flightTimeHours * 3600 * 1000);
        } else {
          flight.plannedDuration = 600000 + Math.random() * 900000;
        }
        
        flight.windFactor = (Math.random() * 0.05) - 0.025;
        flight.turbulence = Math.random() * 0.05;
        flight.lastHeadingUpdateTime = 0;
      }
    }
  });
  
  // Continue animation loop
  requestAnimationFrame(animateFlights);
}

// Calculate REALISTIC flight information with proper aviation mathematics
function calculateFlightInfo(flight, progress, currentPoint, nextPoint, segmentProgress) {
  const totalPathPoints = flight.path.length - 1;
  const currentIndex = Math.floor(progress * totalPathPoints);
  
  // Calculate actual heading based on current path segment
  let heading = 0;
  if (currentPoint && nextPoint) {
    heading = Math.round(calculateHeading(currentPoint.lat, currentPoint.lon, nextPoint.lat, nextPoint.lon));
    
    // Add micro-variations based on turbulence
    const turbulenceEffect = Math.sin(Date.now() / 2000 + flight.seed * 10) * flight.turbulence * 2;
    heading += turbulenceEffect;
    
    // Normalize heading to 0-359
    heading = Math.round((heading + 360) % 360);
  }

  // REALISTIC AIRPORT ELEVATIONS - not fucking 1500ft for everything
  const airportElevations = {
    'BLR': 3000,  // Bangalore - 3000ft elevation
    'DEL': 777,   // Delhi - 777ft elevation  
    'BOM': 39,    // Mumbai - 39ft elevation (sea level)
    'MAA': 52,    // Chennai - 52ft elevation
    'HYD': 1742,  // Hyderabad - 1742ft elevation
    'CCU': 16,    // Kolkata - 16ft elevation
    'CJB': 1342,  // Coimbatore - 1342ft elevation
    'COK': 106,   // Cochin - 106ft elevation
    'TRV': 15,    // Trivandrum - 15ft elevation
    'MYQ': 2349,  // Mysore - 2349ft elevation
    'IXE': 354,   // Mangalore - 354ft elevation
    'PNQ': 1942,  // Pune - 1942ft elevation
    'GOI': 150,   // Goa - 150ft elevation
    'IXM': 459,   // Madurai - 459ft elevation
    'HAL': 2927,  // HAL Bangalore - 2927ft elevation
    'JKD': 2961,  // Jakkur - 2961ft elevation
    'YLK': 2996,  // Yelahanka - 2996ft elevation
    // International airports
    'DXB': 62,    // Dubai - 62ft elevation
    'SIN': 22,    // Singapore - 22ft elevation
    'KUL': 69,    // Kuala Lumpur - 69ft elevation
    'BKK': 5,     // Bangkok - 5ft elevation
    'CMB': 30,    // Colombo - 30ft elevation
    'DOH': 35,    // Doha - 35ft elevation
    // Default for unknown airports
    'DEFAULT': 500
  };
  
  // Get realistic elevations for origin and destination
  const originElevation = airportElevations[flight.origin] || airportElevations['DEFAULT'];
  const destinationElevation = airportElevations[flight.destination] || airportElevations['DEFAULT'];
  
  // Calculate altitude based on flight phase with REALISTIC transitions
  let altitude, groundSpeed;
  
  // Base cruise altitude and speed that vary by aircraft type/route
  if (!flight.cruiseAlt) {
    if (flight.distanceNM && flight.cruiseSpeedKts) {
      // Use realistic altitude ranges based on distance
      if (flight.distanceNM < 200) {
        // Regional jets / smaller aircraft
        flight.cruiseAlt = Math.min(30000, 25000 + Math.floor(Math.random() * 5000));
        flight.cruiseSpeed = Math.min(420, flight.cruiseSpeedKts);
      } else if (flight.distanceNM < 800) {
        // Medium range - 737/A320 types, realistic cruise altitudes
        flight.cruiseAlt = Math.min(40000, Math.max(33000, 32000 + Math.floor(Math.random() * 8000)));
        flight.cruiseSpeed = Math.min(490, Math.max(420, flight.cruiseSpeedKts));
      } else {
        // Long range - wide body jets, high altitude cruise
        flight.cruiseAlt = Math.min(40000, Math.max(33000, 35000 + Math.floor(Math.random() * 5000)));
        flight.cruiseSpeed = Math.min(490, Math.max(450, flight.cruiseSpeedKts));
      }
    } else {
      // Fallback calculation
      const directDistance = Math.sqrt(
        Math.pow(flight.path[0].lat - flight.path[flight.path.length-1].lat, 2) + 
        Math.pow(flight.path[0].lon - flight.path[flight.path.length-1].lon, 2)
      );
      
      if (directDistance < 3) {
        flight.cruiseAlt = Math.min(30000, 25000 + Math.floor(Math.random() * 5000));
        flight.cruiseSpeed = Math.min(420, 350 + Math.floor(Math.random() * 70));
      } else if (directDistance < 7) {
        flight.cruiseAlt = Math.min(40000, Math.max(33000, 32000 + Math.floor(Math.random() * 8000)));
        flight.cruiseSpeed = Math.min(490, Math.max(420, 420 + Math.floor(Math.random() * 60)));
      } else {
        flight.cruiseAlt = Math.min(40000, Math.max(33000, 35000 + Math.floor(Math.random() * 5000)));
        flight.cruiseSpeed = Math.min(490, Math.max(450, 450 + Math.floor(Math.random() * 50)));
      }
    }
  }
  
  const cruiseAltitude = flight.cruiseAlt;
  
  // REALISTIC FLIGHT PHASES WITH PROPER DISTANCES
  if (progress < 0.25) {
    // EXTENDED CLIMB PHASE - more realistic than 15%
    const climbProgress = progress / 0.25;
    const easeInOut = climbProgress < 0.5 
      ? 2 * climbProgress * climbProgress 
      : 1 - Math.pow(-2 * climbProgress + 2, 2) / 2;
    
    // Start from actual airport elevation, not 1500ft
    altitude = originElevation + easeInOut * (cruiseAltitude - originElevation);
    
    // Realistic climb speeds
    if (altitude < 10000) {
      // Below 10,000 ft - limited to 250 knots
      groundSpeed = 170 + easeInOut * 80; // 170-250 knots
    } else {
      // Above 10,000 ft - can accelerate more gradually
      const climbAbove10kProgress = Math.max(0, (altitude - 10000) / (cruiseAltitude - 10000));
      groundSpeed = 250 + climbAbove10kProgress * (flight.cruiseSpeed - 250);
    }
  } 
  else if (progress > 0.75) {
    // EXTENDED DESCENT PHASE - more realistic than 85%
    const descentProgress = (progress - 0.75) / 0.25;
    const easeInOut = descentProgress < 0.5 
      ? 2 * descentProgress * descentProgress 
      : 1 - Math.pow(-2 * descentProgress + 2, 2) / 2;
    
    // End at actual destination airport elevation
    altitude = cruiseAltitude - easeInOut * (cruiseAltitude - destinationElevation);
    
    // REALISTIC DESCENT RATES - 300-500 ft per nautical mile, not 9000ft in 10km!
    if (altitude < 10000) {
      // Below 10,000 ft - must be at 250 knots or lower
      const descentBelow10kProgress = Math.max(0, (10000 - altitude) / (10000 - destinationElevation));
      groundSpeed = 250 - descentBelow10kProgress * 80; // 250-170 knots
    } else {
      // Above 10,000 ft - gradually decreasing
      const descentAbove10kProgress = (cruiseAltitude - altitude) / (cruiseAltitude - 10000);
      groundSpeed = flight.cruiseSpeed - descentAbove10kProgress * (flight.cruiseSpeed - 250);
    }
  } 
  else {
    // CRUISE PHASE - 50% of flight time in cruise, realistic!
    const cruisePhaseProgress = (progress - 0.25) / 0.5; // Normalized progress through cruise phase
    const sineWave = Math.sin(cruisePhaseProgress * Math.PI * 3 + flight.seed * 10) * 0.5;
    
    // Create natural altitude variations (aircraft never maintain perfectly level flight)
    altitude = cruiseAltitude + sineWave * 200; // Slightly larger variations for realism
    
    // Create natural speed variations (due to wind, small course adjustments, etc)
    groundSpeed = flight.cruiseSpeed + sineWave * 10; 
    
    // Apply wind factor to cruise speed
    groundSpeed = groundSpeed * (1 + flight.windFactor * 0.3);
  }
  
  // Ensure realistic altitude minimums based on terrain and airport elevations
  const minAltitude = Math.max(originElevation, destinationElevation) + 200; // Stay well above airport elevation
  const maxAltitude = Math.min(41000, cruiseAltitude + 2000); // Don't exceed reasonable limits
  altitude = Math.max(minAltitude, Math.min(altitude, maxAltitude));
  groundSpeed = Math.max(150, Math.min(groundSpeed, 550));
  
  // Add random micro-variation to flight parameters based on turbulence
  if (flight.turbulence > 0.05) {
    const turbulenceAltEffect = (Math.random() * 2 - 1) * flight.turbulence * 100; // Larger for realism
    altitude += turbulenceAltEffect;
    
    // Re-enforce minimums after turbulence
    altitude = Math.max(minAltitude, Math.min(altitude, maxAltitude));
    
    const turbulenceSpeedEffect = (Math.random() * 2 - 1) * flight.turbulence * 8;
    groundSpeed += turbulenceSpeedEffect;
    groundSpeed = Math.max(150, Math.min(groundSpeed, 550));
  }

  return { 
    altitude: Math.round(altitude),
    groundSpeed: Math.round(groundSpeed),
    heading,
    verticalSpeed: calculateVerticalSpeed(progress, altitude, flight),
    turbulence: flight.turbulence > 0.15 ? "Moderate" : flight.turbulence > 0.05 ? "Light" : "Smooth"
  };
}

// Calculate REALISTIC vertical speed with proper aviation mathematics
function calculateRealisticVerticalSpeed(progress, currentAltitude, flight, cruiseAltitude, originElevation, destinationElevation) {
  // Realistic vertical speed ranges based on aviation data:
  // Climb: 1000-3000 fpm (commercial jets)
  // Cruise: ±100 fpm (minor altitude adjustments)
  // Descent: 1500-2500 fpm (standard procedures)
  // Approach: 300-800 fpm (stabilized approach)
  
  if (progress < 0.20) {
    // CLIMB PHASE - realistic climb rates
    const climbProgress = progress / 0.20;
    
    if (currentAltitude < 3000) {
      // Initial climb after takeoff - steep climb
      return Math.round(2000 + Math.sin(climbProgress * Math.PI) * 800); // 1200-2800 fpm
    } else if (currentAltitude < 10000) {
      // Continued climb below 10,000ft
      const altFactor = (currentAltitude - 3000) / 7000;
      return Math.round(2200 - altFactor * 400 + Math.sin(climbProgress * Math.PI * 2) * 200); // 1600-2400 fpm
    } else {
      // High altitude climb - decreasing climb rate
      const highAltFactor = (currentAltitude - 10000) / (cruiseAltitude - 10000);
      return Math.round(1800 - highAltFactor * 800 + Math.sin(climbProgress * Math.PI) * 100); // 900-1900 fpm
    }
  }
  else if (progress < 0.75) {
    // CRUISE PHASE - minimal vertical movement with realistic adjustments
    const cruiseProgress = (progress - 0.20) / 0.55;
    
    // Small altitude adjustments for weather, traffic, optimization
    const adjustmentCycle = Math.sin(cruiseProgress * Math.PI * 4 + flight.seed * 3);
    const windEffect = Math.sin(Date.now() / 10000 + flight.seed * 2) * 0.3;
    
    // Occasional step climbs or descents (realistic for fuel efficiency)
    const stepChange = Math.sin(cruiseProgress * Math.PI * 0.5) * 0.2;
    
    const baseVS = (adjustmentCycle + windEffect + stepChange) * 80; // ±80 fpm typical
    return Math.round(baseVS * (1 + flight.turbulence * 2)); // Turbulence increases variations
  }
  else if (progress < 0.95) {
    // DESCENT PHASE - proper descent rates
    const descentProgress = (progress - 0.75) / 0.20;
    
    if (currentAltitude > 18000) {
      // High altitude descent - can be aggressive
      return Math.round(-2200 - Math.sin(descentProgress * Math.PI) * 500); // -1700 to -2700 fpm
    } else if (currentAltitude > 10000) {
      // Medium altitude descent - standard rates
      const altFactor = (18000 - currentAltitude) / 8000;
      return Math.round(-1800 - altFactor * 400 - Math.sin(descentProgress * Math.PI * 2) * 200); // -1400 to -2400 fpm
    } else {
      // Low altitude descent - preparing for approach
      const approachPrep = (10000 - currentAltitude) / (10000 - destinationElevation - 2000);
      return Math.round(-1200 - approachPrep * 400); // -1200 to -1600 fpm
    }
  }
  else {
    // FINAL APPROACH / LANDING PHASE - stabilized approach requirements
    const finalProgress = (progress - 0.95) / 0.05;
    const altitudeAboveDestination = currentAltitude - destinationElevation;
    
    if (altitudeAboveDestination <= 100) {
      // LANDED or taxi phase
      return Math.round(-50 + finalProgress * 50); // Nearly 0 fpm when landed
    } else if (altitudeAboveDestination < 500) {
      // Short final - very shallow descent
      return Math.round(-300 - Math.sin(finalProgress * Math.PI) * 100); // -200 to -400 fpm
    } else if (altitudeAboveDestination < 1500) {
      // Final approach - stabilized 3° glide slope ≈ 500-700 fpm
      const glideSlopeVS = -500 - finalProgress * 200; // -500 to -700 fpm
      return Math.round(glideSlopeVS + Math.sin(finalProgress * Math.PI * 3) * 50); // Small variations
    } else {
      // Extended final - transitioning to approach
      return Math.round(-800 - finalProgress * 300); // -800 to -1100 fpm
    }
  }
}

// Calculate vertical speed in feet per minute based on phase of flight
function calculateVerticalSpeed(progress, altitude, flight, originElevation = 1500, destinationElevation = 1500) {
  if (progress < 0.25) {
    // REALISTIC CLIMB PHASE
    const climbProgress = progress / 0.25;
    if (climbProgress < 0.3) {
      // Initial climb: 1500-2500 fpm (realistic for commercial aircraft)
      return Math.round(1500 + 1000 * (climbProgress / 0.3));
    } else if (climbProgress < 0.7) {
      // Mid climb: 2000-2800 fpm
      return Math.round(2000 + 800 * Math.sin(climbProgress * Math.PI));
    } else {
      // Level off: 2500-0 fpm
      return Math.round(2500 * (1 - ((climbProgress - 0.7) / 0.3)));
    }
  } 
  else if (progress > 0.75) {
    // REALISTIC DESCENT PHASE  
    const descentProgress = (progress - 0.75) / 0.25;
    
    // Calculate realistic descent rate based on remaining altitude and distance
    const remainingAltitude = altitude - destinationElevation;
    const remainingProgress = 1 - progress;
    
    if (descentProgress < 0.3) {
      // Initial descent: 0 to -800 fpm (gradual start)
      return Math.round(-800 * (descentProgress / 0.3));
    } else if (descentProgress < 0.8) {
      // Mid descent: -800 to -1200 fpm (standard descent rate)
      const baseRate = -800;
      const additionalRate = -400 * ((descentProgress - 0.3) / 0.5);
      return Math.round(baseRate + additionalRate);
    } else {
      // Final approach: -1200 to -500 fpm (gentler for landing)
      const approachRate = -1200 + 700 * ((descentProgress - 0.8) / 0.2);
      return Math.round(approachRate);
    }
  } 
  else {
    // CRUISE PHASE - minimal vertical movement with realistic variations
    const cruiseVariation = Math.sin(Date.now() / 30000 + flight.seed * 5) * 50; // Very small variations
    return Math.round(cruiseVariation * flight.turbulence); // Affected by turbulence
  }
}

// Update the position of a plane with more natural movement
function updatePlanePosition(plane, flight, progress, flightInfo) {
  const exactIndex = progress * (flight.path.length - 1);
  const index = Math.floor(exactIndex);
  const nextIndex = Math.min(index + 1, flight.path.length - 1);
  const t = exactIndex - index;
  
  const currentPoint = flight.path[index];
  const nextPoint = flight.path[nextIndex];
  
  // Use great circle interpolation for realistic flight paths
  const interpolatedPos = interpolateGreatCircle(
    currentPoint.lat, currentPoint.lon,
    nextPoint.lat, nextPoint.lon,
    t
  );
  
  // Much more subtle turbulence effect
  const time = Date.now() / 2000; // Slower time for turbulence
  const turbFactor = flight.turbulence * Math.sin(time * 0.2 + flight.seed * 10) * 0.00005; // Even smaller
  const turbLat = interpolatedPos.lat + turbFactor;
  const turbLon = interpolatedPos.lon + turbFactor * 0.3;
  
  // Get heading directly from flight info
  const angle = flightInfo.heading;
  
  const pixels = coordsToPixels(turbLat, turbLon);
  
  // Update the plane div (overlay on top of Leaflet map)
  plane.style.left = pixels.x + 'px';
  plane.style.top = pixels.y + 'px';
  plane.style.transform = `translate(-50%, -50%) rotate(${angle - 90}deg)`;
  
  // Update the corresponding Leaflet marker with throttled rotation updates
  const leafletMarker = leafletMarkers[flight.id];
  if (leafletMarker) {
    // Update marker position with great circle interpolation
    leafletMarker.setLatLng([turbLat, turbLon]);
    
    // Throttle heading updates to reduce flickering
    const now = Date.now();
    if (!flight.lastHeadingUpdateTime || now - flight.lastHeadingUpdateTime > 300) {
      updateLeafletRotation(leafletMarker, angle);
      flight.lastHeadingUpdateTime = now;
    }
  }
  
  // Update tooltip if it's showing
  const tooltip = document.getElementById('tooltip');
  if (tooltip && tooltip.style.opacity === '1' && document.querySelector(':hover') === plane) {
    const planeRect = plane.getBoundingClientRect();
    tooltip.style.left = `${planeRect.left + planeRect.width/2}px`;
    tooltip.style.top = `${planeRect.top - tooltip.offsetHeight - 10}px`;
  }
  
  // Update highlight position if this plane is highlighted
  if (plane.classList.contains('highlighted')) {
    const highlight = document.getElementById('pulsing-highlight');
    if (highlight) {
      highlight.style.left = pixels.x + 'px';
      highlight.style.top = pixels.y + 'px';
    }
  }
}

// Show tooltip with detailed flight information
function showTooltip(event) {
  const plane = event.target;
  
  // Clear any existing timeout
  if (tooltipTimeout) {
    clearTimeout(tooltipTimeout);
    tooltipTimeout = null;
  }
  
  // Get current flight data
  const flightId = plane.id;
  const flight = flightData.find(f => f.id === flightId);
  
  if (!flight) return;
  
  // Store current target
  currentTooltipTarget = plane;
  
  // Calculate current progress and flight information
  const now = Date.now();
  const elapsedTime = now - flight.actualStartTime;
  const progress = Math.min(1, Math.max(0, elapsedTime / flight.plannedDuration));
  
  // Get current path position
  const totalPathPoints = flight.path.length - 1;
  const exactIndex = progress * totalPathPoints;
  const currentIndex = Math.floor(exactIndex);
  const nextIndex = Math.min(currentIndex + 1, totalPathPoints);
  const currentPoint = flight.path[currentIndex];
  const nextPoint = flight.path[nextIndex];
  const segmentProgress = exactIndex - currentIndex;
  
  // Get detailed flight info
  const flightInfo = calculateFlightInfo(flight, progress, currentPoint, nextPoint, segmentProgress);
  
  // Create or get tooltip element
  let tooltip = document.getElementById('tooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'tooltip';
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
  }
  
  // Format values correctly
  const formattedHeading = flightInfo.heading.toString().padStart(3, '0');
  const vsSign = flightInfo.verticalSpeed >= 0 ? '+' : '';
  
  // Use phase from flightInfo calculation
  let phaseText = flightInfo.flightPhase || "En Route";
  else if (progress > 0.85) phaseText = "Descending";
  
  // Simple classic layout - more compact and clearer
  tooltip.innerHTML = `
    <div style="border-left: 4px solid ${flight.color}; padding-left: 8px;">
      <div style="font-weight: bold; font-size: 14px; margin-bottom: 4px;">${flight.callsign}</div>
      <div style="font-size: 12px;">${flight.origin} → ${flight.destination} (${phaseText})</div>
      <div style="font-size: 12px; margin-top: 6px;">
        ALT: ${flightInfo.altitude.toLocaleString()} ft · 
        SPD: ${flightInfo.groundSpeed} kts
      </div>
      <div style="font-size: 12px;">
        HDG: ${formattedHeading}° · 
        V/S: ${vsSign}${flightInfo.verticalSpeed} fpm
      </div>
      ${flightInfo.turbulence !== 'Smooth' ? 
        `<div style="font-size: 11px; margin-top: 4px; color: ${flightInfo.turbulence === 'Moderate' ? '#ffcc00' : '#a9a9a9'};">${flightInfo.turbulence} Turbulence</div>` 
        : ''}
    </div>
  `;
  
  // Position tooltip above the plane
  const planeRect = plane.getBoundingClientRect();
  tooltip.style.left = `${planeRect.left + planeRect.width/2}px`;
  tooltip.style.top = `${planeRect.top - tooltip.offsetHeight - 10}px`;
  tooltip.style.transform = 'translateX(-50%)';
  tooltip.style.opacity = '1';
  tooltip.style.visibility = 'visible';
  tooltip.style.pointerEvents = 'none'; // Prevent tooltip from interfering with mouse events
  
  isTooltipVisible = true;
}

// Hide tooltip
function hideTooltip() {
  // Clear any existing timeout
  if (tooltipTimeout) {
    clearTimeout(tooltipTimeout);
    tooltipTimeout = null;
  }
  
  const tooltip = document.getElementById('tooltip');
  if (tooltip) {
    tooltip.style.opacity = '0';
    tooltip.style.visibility = 'hidden';
    tooltip.style.pointerEvents = 'none';
  }
  
  currentTooltipTarget = null;
  isTooltipVisible = false;
}

// Hide tooltip with delay to prevent flickering
function hideTooltipDelayed() {
  // Clear any existing timeout
  if (tooltipTimeout) {
    clearTimeout(tooltipTimeout);
  }
  
  // Hide tooltip after a short delay
  tooltipTimeout = setTimeout(() => {
    hideTooltip();
  }, 100);
}

// Show tooltip for Leaflet marker
function showTooltipForMarker(marker, flight) {
  // Clear any existing timeout
  if (tooltipTimeout) {
    clearTimeout(tooltipTimeout);
    tooltipTimeout = null;
  }
  
  // Get current flight data
  const now = Date.now();
  const elapsedTime = now - flight.actualStartTime;
  const progress = Math.min(1, Math.max(0, elapsedTime / flight.plannedDuration));
  
  // Get current path position
  const totalPathPoints = flight.path.length - 1;
  const exactIndex = progress * totalPathPoints;
  const currentIndex = Math.floor(exactIndex);
  const nextIndex = Math.min(currentIndex + 1, totalPathPoints);
  const currentPoint = flight.path[currentIndex];
  const nextPoint = flight.path[nextIndex];
  const segmentProgress = exactIndex - currentIndex;
  
  // Get detailed flight info
  const flightInfo = calculateFlightInfo(flight, progress, currentPoint, nextPoint, segmentProgress);
  
  // Create or get tooltip element
  let tooltip = document.getElementById('tooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'tooltip';
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
  }
  
  // Store current target
  currentTooltipTarget = marker;
  
  // Format values correctly
  const formattedHeading = flightInfo.heading.toString().padStart(3, '0');
  const vsSign = flightInfo.verticalSpeed >= 0 ? '+' : '';
  
  // Use phase from flightInfo calculation
  let phaseText = flightInfo.flightPhase || "En Route";
  else if (progress > 0.85) phaseText = "Descending";
  
  // Simple classic layout - more compact and clearer
  tooltip.innerHTML = `
    <div style="border-left: 4px solid ${flight.color}; padding-left: 8px;">
      <div style="font-weight: bold; font-size: 14px; margin-bottom: 4px;">${flight.callsign}</div>
      <div style="font-size: 12px;">${flight.origin} → ${flight.destination} (${phaseText})</div>
      <div style="font-size: 12px; margin-top: 6px;">
        ALT: ${flightInfo.altitude.toLocaleString()} ft · 
        SPD: ${flightInfo.groundSpeed} kts
      </div>
      <div style="font-size: 12px;">
        HDG: ${formattedHeading}° · 
        V/S: ${vsSign}${flightInfo.verticalSpeed} fpm
      </div>
      ${flightInfo.turbulence !== 'Smooth' ? 
        `<div style="font-size: 11px; margin-top: 4px; color: ${flightInfo.turbulence === 'Moderate' ? '#ffcc00' : '#a9a9a9'};">${flightInfo.turbulence} Turbulence</div>` 
        : ''}
    </div>
  `;
  
  // Position tooltip near the marker
  const markerElement = marker.getElement();
  if (markerElement) {
    const markerRect = markerElement.getBoundingClientRect();
    tooltip.style.left = `${markerRect.left + markerRect.width/2}px`;
    tooltip.style.top = `${markerRect.top - tooltip.offsetHeight - 10}px`;
    tooltip.style.transform = 'translateX(-50%)';
    tooltip.style.opacity = '1';
    tooltip.style.visibility = 'visible';
    tooltip.style.pointerEvents = 'none'; // Prevent tooltip from interfering with mouse events
  }
  
  isTooltipVisible = true;
}

// Handle window resize and sidebar toggle
function handleResize() {
  initializeMapDimensions(); // Recalculate dimensions
  
  // Invalidate the Leaflet map size to force a redraw
  if (leafletMap) {
    leafletMap.invalidateSize();
  }
  
  // Resize and redraw all path canvases
  Object.values(pathCanvases).forEach(canvas => {
    if (canvas) {
      canvas.width = MAP_WIDTH;
      canvas.height = MAP_HEIGHT;
      // Find the flight for this canvas and redraw its path
      const flight = flightData.find(f => `path-${f.id}` === canvas.id);
      if (flight) {
        drawFlightPath(canvas, flight, flight.progress);
      }
    }
  });

  // Update plane positions
  flightData.forEach(flight => {
    const plane = planeDivs[flight.id];
    if (plane) {
      // Calculate current progress and flight info for proper positioning
      const now = Date.now();
      const elapsedTime = now - flight.actualStartTime;
      const progress = Math.min(1, Math.max(0, elapsedTime / flight.plannedDuration));
      
      // Get current path segment for flight info calculation
      const totalPathPoints = flight.path.length - 1;
      const exactIndex = progress * totalPathPoints;
      const currentIndex = Math.floor(exactIndex);
      const nextIndex = Math.min(currentIndex + 1, totalPathPoints);
      const segmentProgress = exactIndex - currentIndex;
      const currentPoint = flight.path[currentIndex];
      const nextPoint = flight.path[nextIndex];
      
      // Calculate flight info properly
      const flightInfo = calculateFlightInfo(flight, progress, currentPoint, nextPoint, segmentProgress);
      
      updatePlanePosition(plane, flight, progress, flightInfo);
    }
  });
  console.log("Map and flights redrawn after resize/toggle.");
}

// Set up sidebar toggle functionality
function setupSidebarToggle() {
  const toggleButton = document.querySelector('.sidebar-toggle');
  const sidebar = document.querySelector('.sidebar');
  // mainContent is not strictly needed here if we rely on flex layout

  if (toggleButton && sidebar) {
    toggleButton.addEventListener('click', function() {
      sidebarVisible = !sidebarVisible;
      
      if (sidebarVisible) {
        sidebar.classList.remove('collapsed');
        sidebar.style.width = '280px';
        this.style.transform = 'rotate(180deg)';
      } else {
        sidebar.classList.add('collapsed');
        sidebar.style.width = '32px';
        this.style.transform = 'rotate(0deg)';
      }
      // Dispatch a resize event to trigger map redraw
      // Use a timeout to allow CSS transitions to start
      setTimeout(() => window.dispatchEvent(new Event('resize')), 50);
    });
  }
}

// Initialize the map and flights
function initializeMap() {
  console.log("Starting map initialization");
  
  // Show loading overlay
  showLoadingOverlay();
  
  initializeMapDimensions();
  
  // Initialize the Leaflet map first
  initializeLeafletMap();
  
  addMapFeatures();
  
  flightData = generateFlights();
  
  flightData.forEach(flight => {
    planeDivs[flight.id] = createPlane(flight);
    leafletMarkers[flight.id] = createPlaneMarker(flight); // Add Leaflet markers
    pathCanvases[flight.id] = createPathCanvas(flight);
  });
  
  initializeRecentFlights();
  setupSidebarToggle(); // Setup toggle after elements are in DOM
  
  // Add click handler to the map to clear highlights when clicking on an empty area
  const map = document.getElementById('flight-map');
  map.addEventListener('click', function(event) {
    // Only clear if the click was directly on the map (not on a plane)
    if (event.target === map) {
      clearAllHighlights();
      
      // Remove the pulsing highlight effect
      const highlight = document.getElementById('pulsing-highlight');
      if (highlight) {
        highlight.remove();
      }
    }
  });
  
  // Add global mousemove listener to hide tooltip when not hovering over planes
  document.addEventListener('mousemove', function(event) {
    if (!isTooltipVisible) return;
    
    // Check if mouse is over a plane element or leaflet marker
    const elementUnderMouse = document.elementFromPoint(event.clientX, event.clientY);
    const isOverPlane = elementUnderMouse && (
      elementUnderMouse.classList.contains('plane') ||
      elementUnderMouse.classList.contains('plane-icon') ||
      elementUnderMouse.closest('.plane-marker')
    );
    
    // If not over a plane and tooltip is visible, hide it
    if (!isOverPlane && isTooltipVisible) {
      hideTooltipDelayed();
    }
  });
  
  if (!animationRunning) {
    animationRunning = true;
    animateFlights();
  }
  
  window.addEventListener('resize', handleResize);
  console.log("Map initialization complete");
}

// Show loading overlay with progress updates
function showLoadingOverlay() {
  const overlay = document.getElementById('loading-overlay');
  const progressBar = document.getElementById('loading-progress-bar');
  
  if (overlay) {
    overlay.classList.remove('hidden');
    progressBar.style.width = '0%';
  }
}

// Hide loading overlay
function hideLoadingOverlay() {
  const overlay = document.getElementById('loading-overlay');
  
  if (overlay) {
    overlay.classList.add('hidden');
    // Remove the overlay from DOM after transition
    setTimeout(() => {
      if (overlay.parentNode) {
        overlay.style.display = 'none';
      }
    }, 500);
  }
}

// Update loading progress
function updateLoadingProgress(progress) {
  const progressBar = document.getElementById('loading-progress-bar');
  const subtitle = document.querySelector('.loading-subtitle');
  
  if (progressBar) {
    progressBar.style.width = `${progress * 100}%`;
  }
  
  if (subtitle) {
    if (progress < 0.3) {
      subtitle.textContent = 'Initializing radar systems...';
    } else if (progress < 0.6) {
      subtitle.textContent = 'Loading flight data...';
    } else if (progress < 0.9) {
      subtitle.textContent = 'Starting flight tracking...';
    } else {
      subtitle.textContent = 'Ready for takeoff!';
    }
  }
}

// Start initialization when DOM is ready
document.addEventListener('DOMContentLoaded', initializeMap); 

// Flight following functions
function startFollowingFlight(flight) {
  followingFlight = flight;
  followingEnabled = true;
  
  // Add following mode class to body to hide airport markers
  document.body.classList.add('following-mode');
  
  // Disable map interaction during following
  if (leafletMap) {
    leafletMap.dragging.disable();
    leafletMap.scrollWheelZoom.disable();
    leafletMap.doubleClickZoom.disable();
    leafletMap.touchZoom.disable();
  }
  
  // Add following visual indicator to the card
  const flightCard = document.getElementById(`card-${flight.id}`);
  if (flightCard) {
    flightCard.classList.add('following');
  }
  
  // Highlight the Leaflet marker
  const leafletMarker = leafletMarkers[flight.id];
  if (leafletMarker && leafletMarker.getElement()) {
    leafletMarker.getElement().classList.add('highlighted');
  }
  
  // Show the detailed following view in sidebar
  showFollowingDetailView(flight);
  
  console.log(`Started following flight ${flight.callsign}`);
}

function stopFollowingFlight() {
  // Remove following mode class from body to show airport markers again
  document.body.classList.remove('following-mode');
  
  // Remove following visual indicator
  if (followingFlight) {
    const flightCard = document.getElementById(`card-${followingFlight.id}`);
    if (flightCard) {
      flightCard.classList.remove('following');
    }
    
    // Remove highlight from Leaflet marker
    const leafletMarker = leafletMarkers[followingFlight.id];
    if (leafletMarker && leafletMarker.getElement()) {
      leafletMarker.getElement().classList.remove('highlighted');
    }
  }
  
  followingFlight = null;
  followingEnabled = false;
  
  // Re-enable map interaction
  if (leafletMap) {
    leafletMap.dragging.enable();
    leafletMap.scrollWheelZoom.enable();
    leafletMap.doubleClickZoom.enable();
    leafletMap.touchZoom.enable();
  }
  
  // Reset to default view
  if (leafletMap) {
    leafletMap.setView([13.0, 77.6], 11);
  }
  
  // Hide the detailed following view and show normal flight list
  hideFollowingDetailView();
  
  console.log("Stopped following flight");
}

function updateFollowingCamera(flight, progress) {
  if (!followingEnabled || !followingFlight || followingFlight.id !== flight.id || !leafletMap) {
    return;
  }
  
  // Calculate current flight position
  const exactIndex = progress * (flight.path.length - 1);
  const index = Math.floor(exactIndex);
  const nextIndex = Math.min(index + 1, flight.path.length - 1);
  const t = exactIndex - index;
  
  const currentPoint = flight.path[index];
  const nextPoint = flight.path[nextIndex];
  
  // Interpolate current position
  const currentLat = currentPoint.lat + (nextPoint.lat - currentPoint.lat) * t;
  const currentLon = currentPoint.lon + (nextPoint.lon - currentPoint.lon) * t;
  
  // Calculate MUCH CLOSER zoom level based on flight phase
  let zoomLevel = 17; // Increased base zoom for better detail
  if (progress < 0.15) {
    // Takeoff/climb phase - VERY close zoom
    zoomLevel = 19; // Was 16, now much closer
  } else if (progress > 0.85) {
    // Descent/landing phase - VERY close zoom
    zoomLevel = 19; // Was 16, now much closer
  } else {
    // Cruise phase - closer zoom
    zoomLevel = 17; // Was 14, now much closer
  }
  
  // Smooth camera movement with shorter duration for better following
  leafletMap.setView([currentLat, currentLon], zoomLevel, {
    animate: true,
    duration: 0.5 // Reduced to 0.5 seconds for more responsive following
  });
}

// Check if a flight's current position is within the visible map bounds

// Show detailed following view in sidebar
function showFollowingDetailView(flight) {
  // Hide normal flight list
  const flightsContainer = document.querySelector('.flights-container');
  if (flightsContainer) {
    flightsContainer.style.display = 'none';
  }
  
  // Show and populate the following detail view
  const detailView = document.getElementById('following-detail-view');
  if (!detailView) return;
  
  // Get current flight info
  const now = Date.now();
  const elapsedTime = now - flight.actualStartTime;
  const progress = Math.min(1, Math.max(0, elapsedTime / flight.plannedDuration));
  
  const exactIndex = progress * (flight.path.length - 1);
  const index = Math.floor(exactIndex);
  const nextIndex = Math.min(index + 1, flight.path.length - 1);
  const currentPoint = flight.path[index];
  const nextPoint = flight.path[nextIndex];
  const segmentProgress = exactIndex - index;
  
  const flightInfo = calculateFlightInfo(flight, progress, currentPoint, nextPoint, segmentProgress);
  
  // Calculate correct flight phase based on progress
  let phaseText = flightInfo.flightPhase || "En Route";
  
  // Calculate realistic duration
  const flightDuration = calculateFlightDuration(flight);
  
  // Create the detailed view HTML matching Figma design EXACTLY
  detailView.innerHTML = `
    <!-- Mini Map Widget -->
    <div class="mini-map-container" style="margin-bottom: 16px;">
      <div id="following-mini-map" style="height: 280px; border-radius: 8px; background: #4a5c52; position: relative; overflow: hidden;"></div>
    </div>
    
    <!-- Flight Details Section -->
    <div style="border-left: 3px solid ${flight.color}; padding-left: 12px; margin-bottom: 16px;">
      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
        <h2 style="font-family: 'JetBrains Mono', monospace; font-size: 18px; font-weight: 500; margin: 0; color: #fff;">${flight.callsign}</h2>
        <div style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); padding: 2px 8px; border-radius: 4px;">
          <div style="font-size: 12px; color: #fff;">✈︎</div>
          <span style="font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 300; color: rgba(255,255,255,0.5);">${phaseText}</span>
        </div>
      </div>
      
      <!-- Route Display -->
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <div style="text-align: left;">
          <div style="font-family: 'JetBrains Mono', monospace; font-size: 16px; font-weight: 600; color: #fff;">${flight.origin}</div>
          <div style="font-family: 'JetBrains Mono', monospace; font-size: 11px; color: rgba(255,255,255,0.4);">Origin<br>Airport</div>
        </div>
        <div style="flex: 1; display: flex; align-items: center; justify-content: center; margin: 0 16px;">
          <div style="width: 40px; height: 2px; background: rgba(255,255,255,0.3); position: relative; display: flex; align-items: center;">
            <div style="position: absolute; left: 0; width: 6px; height: 6px; border-radius: 50%; background: #fff;"></div>
            <div style="position: absolute; right: 0; width: 6px; height: 6px; border-radius: 50%; background: #fff;"></div>
            <div style="position: absolute; left: 50%; transform: translateX(-50%); width: 2px; height: 2px; background: #fff; border-radius: 50%;"></div>
            <div style="position: absolute; left: 25%; transform: translateX(-50%); width: 2px; height: 2px; background: #fff; border-radius: 50%;"></div>
            <div style="position: absolute; left: 75%; transform: translateX(-50%); width: 2px; height: 2px; background: #fff; border-radius: 50%;"></div>
          </div>
        </div>
        <div style="text-align: right;">
          <div style="font-family: 'JetBrains Mono', monospace; font-size: 16px; font-weight: 600; color: #fff;">${flight.destination}</div>
          <div style="font-family: 'JetBrains Mono', monospace; font-size: 11px; color: rgba(255,255,255,0.4);">Destination<br>Airport</div>
        </div>
      </div>
    </div>
    
    <!-- Flight Data Grid -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
      <div style="display: flex; justify-content: space-between;">
        <span style="font-family: 'JetBrains Mono', monospace; font-size: 14px; color: #fff;">ALT:</span>
        <span data-field="altitude" style="font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 500; color: #fff;">${flightInfo.altitude.toLocaleString()} ft</span>
      </div>
      <div style="display: flex; justify-content: space-between;">
        <span style="font-family: 'JetBrains Mono', monospace; font-size: 14px; color: #fff;">SPD:</span>
        <span data-field="speed" style="font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 500; color: #fff;">${flightInfo.groundSpeed} kts</span>
      </div>
      <div style="display: flex; justify-content: space-between;">
        <span style="font-family: 'JetBrains Mono', monospace; font-size: 14px; color: #fff;">HDG:</span>
        <span data-field="heading" style="font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 500; color: #fff;">${flightInfo.heading.toString().padStart(3, '0')}°</span>
      </div>
      <div style="display: flex; justify-content: space-between;">
        <span style="font-family: 'JetBrains Mono', monospace; font-size: 14px; color: #fff;">V/S:</span>
        <span data-field="vertical-speed" style="font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 500; color: #fff;">${flightInfo.verticalSpeed >= 0 ? '+' : ''}${flightInfo.verticalSpeed} fpm</span>
      </div>
      <div style="display: flex; justify-content: space-between; grid-column: span 2;">
        <span style="font-family: 'JetBrains Mono', monospace; font-size: 14px; color: #fff;">Duration:</span>
        <span style="font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 500; color: #fff;">${flightDuration}</span>
      </div>
    </div>
    
    <!-- SparkLine Progress Widget -->
    <div class="spark-line-container" style="margin-bottom: 16px;">
      <div style="font-size: 11px; color: rgba(255,255,255,0.4); margin-bottom: 6px; font-family: 'JetBrains Mono', monospace;">Route Progress</div>
      <canvas id="following-spark-line" class="spark-line-canvas" style="width: 100%; height: 40px; border-radius: 4px; background: rgba(255,255,255,0.05);"></canvas>
    </div>
    
    <!-- Turbulence Indicator -->
    ${flightInfo.turbulence !== 'Smooth' ? `
      <div style="background: rgba(243, 126, 25, 0.15); border: 1px solid rgba(243, 126, 25, 0.3); border-radius: 6px; padding: 8px 12px; text-align: center; margin-bottom: 16px;">
        <span style="font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 400; color: #F37E19;">${flightInfo.turbulence} Turbulence</span>
      </div>
    ` : ''}
    
    <!-- Stop Following Button -->
    <div class="stop-following-button" style="display: block !important; background: rgba(255,82,82,0.2); border: 1px solid rgba(255,82,82,0.4); color: #ff5252; padding: 12px; text-align: center; border-radius: 6px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 14px; margin-top: 16px; transition: all 0.2s;">Stop Following</div>
  `;
  
  detailView.style.display = 'block';
  
  // Initialize widgets after a short delay
  setTimeout(() => {
    // Initialize mini-map
    initializeMiniMap(flight, progress);
    
    // Initialize sparkLine
    const sparkCanvas = document.getElementById('following-spark-line');
    if (sparkCanvas) {
      sparkLine(sparkCanvas, flight.path, progress);
      detailView.sparkCanvas = sparkCanvas;
    }
    
    // Add click handler to stop following button with hover effects
    const stopBtn = detailView.querySelector('.stop-following-button');
    if (stopBtn) {
      stopBtn.addEventListener('mouseenter', () => {
        stopBtn.style.background = 'rgba(255,82,82,0.3)';
        stopBtn.style.borderColor = 'rgba(255,82,82,0.6)';
      });
      stopBtn.addEventListener('mouseleave', () => {
        stopBtn.style.background = 'rgba(255,82,82,0.2)';
        stopBtn.style.borderColor = 'rgba(255,82,82,0.4)';
      });
      stopBtn.addEventListener('click', () => {
        stopFollowingFlight();
        clearAllHighlights();
      });
    }
  }, 100);
}

// Hide detailed following view and show normal flight list
function hideFollowingDetailView() {
  // Hide detail view
  const detailView = document.getElementById('following-detail-view');
  if (detailView) {
    detailView.style.display = 'none';
    detailView.innerHTML = '';
  }
  
  // Show normal flight list
  const flightsContainer = document.querySelector('.flights-container');
  if (flightsContainer) {
    flightsContainer.style.display = 'block';
  }
}

// Widget: sparkLine - HTML Canvas mini path visualization
function sparkLine(canvas, points, progress) {
  if (!canvas || !points || points.length < 2) return;
  
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  
  // Handle Hi-DPI displays
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Calculate bounds with 10px padding
  const padding = 10;
  const bounds = points.reduce((acc, point) => ({
    minLat: Math.min(acc.minLat, point.lat),
    maxLat: Math.max(acc.maxLat, point.lat), 
    minLon: Math.min(acc.minLon, point.lon),
    maxLon: Math.max(acc.maxLon, point.lon)
  }), {
    minLat: points[0].lat, maxLat: points[0].lat,
    minLon: points[0].lon, maxLon: points[0].lon
  });
  
  const width = rect.width - 2 * padding;
  const height = rect.height - 2 * padding;
  
  // Normalize coordinates to canvas space
  const normalizePoint = (point) => ({
    x: padding + ((point.lon - bounds.minLon) / (bounds.maxLon - bounds.minLon)) * width,
    y: padding + ((bounds.maxLat - point.lat) / (bounds.maxLat - bounds.minLat)) * height
  });
  
  // Draw dashed path up to progress
  const progressIndex = Math.floor(progress * (points.length - 1));
  const visiblePoints = points.slice(0, progressIndex + 1);
  
  if (visiblePoints.length > 1) {
    ctx.strokeStyle = '#418461AA';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    
    const firstPoint = normalizePoint(visiblePoints[0]);
    ctx.moveTo(firstPoint.x, firstPoint.y);
    
    for (let i = 1; i < visiblePoints.length; i++) {
      const point = normalizePoint(visiblePoints[i]);
      ctx.lineTo(point.x, point.y);
    }
    ctx.stroke();
  }
  
  // Draw start dot (6px solid #2e7e52)
  const startPoint = normalizePoint(points[0]);
  ctx.fillStyle = '#2e7e52';
  ctx.beginPath();
  ctx.arc(startPoint.x, startPoint.y, 3, 0, 2 * Math.PI);
  ctx.fill();
  
  // Draw current dot (5px solid #2e7e52) only if progress < 1
  if (progress < 1 && progressIndex < points.length - 1) {
    const currentIdx = Math.min(progressIndex, points.length - 1);
    const currentPoint = normalizePoint(points[currentIdx]);
    ctx.fillStyle = '#2e7e52';
    ctx.beginPath();
    ctx.arc(currentPoint.x, currentPoint.y, 2.5, 0, 2 * Math.PI);
    ctx.fill();
  }
  
  // Draw end dot (6px, grey until progress = 1)
  const endPoint = normalizePoint(points[points.length - 1]);
  ctx.fillStyle = progress >= 1 ? '#d9534f' : '#eee6e6';
  ctx.beginPath();
  ctx.arc(endPoint.x, endPoint.y, 3, 0, 2 * Math.PI);
  ctx.fill();
}

// Get enhanced flight information with phase detection
function getEnhancedFlightInfo(flight, progress, currentPosition) {
  // Calculate basic flight phase
  let enhancedPhase = 'En Route';
  if (progress < 0.15) enhancedPhase = 'Climbing';
  else if (progress > 0.85) enhancedPhase = 'Descending';
  
  return {
    enhancedPhase,
    nearestAirport: null,
    airportDistance: null,
    isNearAirport: false
  };
}

// SOPHISTICATED AIRPORT PROXIMITY DETECTION ALGORITHMS
function detectNearbyAirports(flight, currentPosition, range = 50) {
  // Define comprehensive airport database for proximity detection
  const allAirports = [
    // Major hubs
    { code: "BLR", name: "Bangalore", lat: 13.1989, lon: 77.7068, type: "major" },
    { code: "DEL", name: "Delhi", lat: 28.5562, lon: 77.1000, type: "major" },
    { code: "BOM", name: "Mumbai", lat: 19.0896, lon: 72.8656, type: "major" },
    { code: "MAA", name: "Chennai", lat: 12.9941, lon: 80.1709, type: "major" },
    { code: "HYD", name: "Hyderabad", lat: 17.2403, lon: 78.4294, type: "major" },
    { code: "CCU", name: "Kolkata", lat: 22.6547, lon: 88.4467, type: "major" },
    // Regional airports
    { code: "CJB", name: "Coimbatore", lat: 11.0300, lon: 77.0434, type: "regional" },
    { code: "COK", name: "Cochin", lat: 10.1518, lon: 76.3930, type: "regional" },
    { code: "TRV", name: "Trivandrum", lat: 8.4833, lon: 76.9200, type: "regional" },
    { code: "MYQ", name: "Mysore", lat: 12.2300, lon: 76.6560, type: "regional" },
    { code: "IXE", name: "Mangalore", lat: 12.9614, lon: 74.8901, type: "regional" },
    { code: "PNQ", name: "Pune", lat: 18.5793, lon: 73.9089, type: "regional" },
    { code: "GOI", name: "Goa", lat: 15.3808, lon: 73.8314, type: "regional" },
    { code: "IXM", name: "Madurai", lat: 9.8343, lon: 78.0833, type: "regional" },
    // Local airfields
    { code: "HAL", name: "HAL Bangalore", lat: 12.9500, lon: 77.6687, type: "local" },
    { code: "JKD", name: "Jakkur Aerodrome", lat: 13.0820, lon: 77.5893, type: "local" },
    { code: "YLK", name: "Yelahanka Air Base", lat: 13.1042, lon: 77.5958, type: "local" }
  ];
  
  const nearbyAirports = [];
  
  allAirports.forEach(airport => {
    const distance = calculateDistanceNM(currentPosition, airport);
    
    if (distance <= range) {
      // Calculate bearing to airport
      const bearing = calculateHeading(currentPosition.lat, currentPosition.lon, airport.lat, airport.lon);
      
      // Determine proximity category based on distance and airport type
      let proximityLevel;
      if (distance < 10) proximityLevel = "immediate";
      else if (distance < 25) proximityLevel = "close";
      else proximityLevel = "nearby";
      
      // Check if flight is approaching or departing this airport
      const approachingOrigin = airport.code === flight.origin && flight.progress < 0.1;
      const approachingDestination = airport.code === flight.destination && flight.progress > 0.9;
      
      nearbyAirports.push({
        ...airport,
        distance: Math.round(distance),
        bearing: Math.round(bearing),
        proximityLevel,
        isOrigin: airport.code === flight.origin,
        isDestination: airport.code === flight.destination,
        isApproaching: approachingOrigin || approachingDestination
      });
    }
  });
  
  // Sort by distance, closest first
  return nearbyAirports.sort((a, b) => a.distance - b.distance);
}

// SOPHISTICATED WIND AND TURBULENCE EFFECTS
function applyRealisticWeatherEffects(flight, currentPosition) {
  const now = Date.now();
  
  // Wind patterns change based on geography and altitude
  const geographicWindFactor = {
    lat: Math.sin(currentPosition.lat * Math.PI / 180) * 0.02, // Latitude-based wind patterns
    lon: Math.cos(currentPosition.lon * Math.PI / 180) * 0.015, // Longitude-based wind patterns
    seasonal: Math.sin((now / (1000 * 60 * 60 * 24 * 30)) * Math.PI) * 0.01 // Monthly wind variation
  };
  
  // Combine wind factors
  const totalWindEffect = flight.windFactor + 
    geographicWindFactor.lat + 
    geographicWindFactor.lon + 
    geographicWindFactor.seasonal;
  
  // Turbulence increases near airports and weather systems
  const nearbyAirports = detectNearbyAirports(flight, currentPosition, 30);
  let turbulenceMultiplier = 1.0;
  
  if (nearbyAirports.length > 0) {
    const closestAirport = nearbyAirports[0];
    if (closestAirport.distance < 15) {
      turbulenceMultiplier = 1.5; // Increased turbulence near airports
    }
  }
  
  return {
    windEffect: totalWindEffect,
    turbulence: flight.turbulence * turbulenceMultiplier,
    nearbyAirports: nearbyAirports.slice(0, 3) // Return up to 3 closest airports
  };
}

// Initialize mini-map widget for following detail view
function initializeMiniMap(flight, progress) {
  const miniMapContainer = document.getElementById('following-mini-map');
  if (!miniMapContainer) return;
  
  // Create mini Leaflet map with BRIGHT, clear styling
  const miniMap = L.map(miniMapContainer, {
    center: [0, 0], // Will be set based on flight route
    zoom: 3,
    zoomControl: false,
    attributionControl: false,
    dragging: false,
    touchZoom: false,
    doubleClickZoom: false,
    scrollWheelZoom: false,
    boxZoom: false,
    tap: false
  });
  
  // Add BRIGHT, high-contrast map tiles
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '',
    opacity: 0.9 // Much higher opacity for better visibility
  }).addTo(miniMap);
  
  // Calculate proper bounds and zoom level using MATH
  const latitudes = flight.path.map(p => p.lat);
  const longitudes = flight.path.map(p => p.lon);
  
  const minLat = Math.min(...latitudes);
  const maxLat = Math.max(...latitudes);
  const minLon = Math.min(...longitudes);
  const maxLon = Math.max(...longitudes);
  
  // Calculate route distance for proper zoom calculation
  const routeDistance = calculateDistanceNM(flight.path[0], flight.path[flight.path.length - 1]);
  
  // PROPER ZOOM MATH based on route distance
  let zoomLevel;
  if (routeDistance < 200) {
    zoomLevel = 7; // Regional flights - closer zoom
  } else if (routeDistance < 1000) {
    zoomLevel = 5; // Medium range flights
  } else if (routeDistance < 3000) {
    zoomLevel = 4; // Long range flights
  } else {
    zoomLevel = 3; // International/transcontinental flights
  }
  
  // Calculate padding based on zoom level for optimal view
  const padding = 0.1 + (0.1 / zoomLevel); // More padding for higher zoom levels
  const bounds = [
    [minLat - padding, minLon - padding],
    [maxLat + padding, maxLon + padding]
  ];
  
  // Fit map to show entire route with calculated bounds
  miniMap.fitBounds(bounds, { padding: [10, 10] });
  
  // Draw BRIGHT, VISIBLE flight route line with proper progress math
  const routeCoords = flight.path.map(point => [point.lat, point.lon]);
  
  // Draw completed path in BRIGHT GREEN
  const completedDistance = Math.floor(progress * (flight.path.length - 1));
  if (completedDistance > 0) {
    const completedCoords = routeCoords.slice(0, completedDistance + 1);
    const completedLine = L.polyline(completedCoords, {
      color: '#4CAF50', // Bright green for completed path
      weight: 4,
      opacity: 1.0,
      smoothFactor: 1
    }).addTo(miniMap);
  }
  
  // Draw remaining path in BRIGHT ORANGE/YELLOW
  if (completedDistance < routeCoords.length - 1) {
    const remainingCoords = routeCoords.slice(completedDistance);
    const remainingLine = L.polyline(remainingCoords, {
      color: '#FF9800', // Bright orange for remaining path
      weight: 3,
      opacity: 0.8,
      dashArray: '8, 8'
    }).addTo(miniMap);
  }
  
  // Add BRIGHT origin airport marker
  const originMarker = L.circleMarker([flight.path[0].lat, flight.path[0].lon], {
    radius: 8,
    color: '#ffffff',
    fillColor: '#4CAF50',
    fillOpacity: 1,
    weight: 3
  }).addTo(miniMap);
  
  // Add BRIGHT destination airport marker  
  const destMarker = L.circleMarker([flight.path[flight.path.length - 1].lat, flight.path[flight.path.length - 1].lon], {
    radius: 8,
    color: '#ffffff',
    fillColor: progress >= 1 ? '#4CAF50' : '#FF9800',
    fillOpacity: 1,
    weight: 3
  }).addTo(miniMap);
  
  // Add BRIGHT current position marker if flight is active
  if (progress < 1) {
    const currentIndex = Math.floor(progress * (flight.path.length - 1));
    const nextIndex = Math.min(currentIndex + 1, flight.path.length - 1);
    const segmentProgress = (progress * (flight.path.length - 1)) - currentIndex;
    
    // INTERPOLATE exact current position using math
    const currentPoint = flight.path[currentIndex];
    const nextPoint = flight.path[nextIndex];
    
    const currentLat = currentPoint.lat + (nextPoint.lat - currentPoint.lat) * segmentProgress;
    const currentLon = currentPoint.lon + (nextPoint.lon - currentPoint.lon) * segmentProgress;
    
    const currentMarker = L.circleMarker([currentLat, currentLon], {
      radius: 6,
      color: '#ffffff',
      fillColor: '#2196F3', // Bright blue for current position
      fillOpacity: 1,
      weight: 3
    }).addTo(miniMap);
    
    // Store for updates
    miniMapContainer.currentMarker = currentMarker;
  }
  
  // Store mini map reference for updates
  miniMapContainer.miniMap = miniMap;
  
  // Add BRIGHT continent/region labels based on route
  addBrightMiniMapLabels(miniMap, flight);
}

// Add bright, visible geographic labels to mini-map
function addBrightMiniMapLabels(miniMap, flight) {
  // Calculate which continents/regions are covered by the route
  const route = flight.path;
  const hasNorthAmerica = route.some(p => p.lat > 25 && p.lat < 70 && p.lon > -160 && p.lon < -50);
  const hasAsia = route.some(p => p.lat > 0 && p.lat < 70 && p.lon > 60 && p.lon < 180);
  const hasEurope = route.some(p => p.lat > 35 && p.lat < 70 && p.lon > -10 && p.lon < 60);
  const hasMiddleEast = route.some(p => p.lat > 15 && p.lat < 45 && p.lon > 35 && p.lon < 75);
  const hasIndia = route.some(p => p.lat > 6 && p.lat < 37 && p.lon > 68 && p.lon < 97);
  
  const labels = [];
  
  if (hasNorthAmerica) {
    labels.push({ text: 'NORTH\nAMERICA', lat: 45, lon: -100, color: '#2c3e50' });
  }
  if (hasAsia) {
    labels.push({ text: 'ASIA', lat: 30, lon: 100, color: '#2c3e50' });
  }
  if (hasEurope) {
    labels.push({ text: 'EUROPE', lat: 50, lon: 10, color: '#2c3e50' });
  }
  if (hasMiddleEast) {
    labels.push({ text: 'MIDDLE EAST', lat: 25, lon: 50, color: '#2c3e50' });
  }
  if (hasIndia) {
    labels.push({ text: 'INDIA', lat: 20, lon: 78, color: '#2c3e50' });
  }
  
  // Add BRIGHT, VISIBLE labels as markers
  labels.forEach(label => {
    const labelDiv = L.divIcon({
      className: 'mini-map-label-bright',
      html: `<div style="
        color: ${label.color}; 
        font-family: 'JetBrains Mono', monospace; 
        font-size: 11px; 
        font-weight: 600; 
        text-align: center; 
        white-space: pre-line; 
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        background: rgba(255,255,255,0.7);
        padding: 2px 4px;
        border-radius: 3px;
      ">${label.text}</div>`,
      iconSize: [90, 35],
      iconAnchor: [45, 17]
    });
    
    L.marker([label.lat, label.lon], { icon: labelDiv }).addTo(miniMap);
  });
}

// Update following detail view in real-time
function updateFollowingDetailView(flight, progress, flightInfo) {
  if (!followingEnabled || !followingFlight || followingFlight.id !== flight.id) {
    return;
  }
  
  const detailView = document.getElementById('following-detail-view');
  if (!detailView || detailView.style.display === 'none') {
    return;
  }
  
  // Update flight phase
  let phaseText = "En Route";
  else if (progress > 0.85) phaseText = "Descending";
  
  const phaseElement = detailView.querySelector('span[style*="rgba(255,255,255,0.5)"]');
  if (phaseElement) {
    phaseElement.textContent = phaseText;
  }
  
  // Update flight data
  const altElement = detailView.querySelector('[data-field="altitude"]');
  const spdElement = detailView.querySelector('[data-field="speed"]');
  const hdgElement = detailView.querySelector('[data-field="heading"]');
  const vsElement = detailView.querySelector('[data-field="vertical-speed"]');
  
  if (altElement) altElement.textContent = `${flightInfo.altitude.toLocaleString()} ft`;
  if (spdElement) spdElement.textContent = `${flightInfo.groundSpeed} kts`;
  if (hdgElement) hdgElement.textContent = `${flightInfo.heading.toString().padStart(3, '0')}°`;
  if (vsElement) vsElement.textContent = `${flightInfo.verticalSpeed >= 0 ? '+' : ''}${flightInfo.verticalSpeed} fpm`;
  
  // Update sparkline
  const sparkCanvas = detailView.sparkCanvas;
  if (sparkCanvas) {
    sparkLine(sparkCanvas, flight.path, progress);
  }
  
  // Update mini-map current position
  const miniMapContainer = document.getElementById('following-mini-map');
  if (miniMapContainer && miniMapContainer.currentMarker && progress < 1) {
    const currentIndex = Math.floor(progress * (flight.path.length - 1));
    const nextIndex = Math.min(currentIndex + 1, flight.path.length - 1);
    const segmentProgress = (progress * (flight.path.length - 1)) - currentIndex;
    
    // INTERPOLATE exact current position using math
    const currentPoint = flight.path[currentIndex];
    const nextPoint = flight.path[nextIndex];
    
    const currentLat = currentPoint.lat + (nextPoint.lat - currentPoint.lat) * segmentProgress;
    const currentLon = currentPoint.lon + (nextPoint.lon - currentPoint.lon) * segmentProgress;
    
    miniMapContainer.currentMarker.setLatLng([currentLat, currentLon]);
  }
  
  // Update turbulence indicator
  const turbElement = detailView.querySelector('span[style*="color: #F37E19"]');
  if (turbElement) {
    if (flightInfo.turbulence === 'Smooth') {
      turbElement.parentElement.parentElement.style.display = 'none';
    } else {
      turbElement.parentElement.parentElement.style.display = 'block';
      turbElement.textContent = `${flightInfo.turbulence} Turbulence`;
    }
  }
}

// FLIGHT HISTORY AND RETURN FLIGHT SYSTEM

// Log completed flight to history
function logCompletedFlight(flight, completionTime) {
  const flightLog = {
    id: flight.id,
    callsign: flight.callsign,
    origin: flight.origin,
    destination: flight.destination,
    completionTime: completionTime,
    totalDuration: flight.plannedDuration,
    distanceNM: flight.distanceNM,
    cruiseSpeedKts: flight.cruiseSpeedKts,
    path: [...flight.path], // Copy the complete path
    timestamp: Date.now()
  };
  
  flightHistory.push(flightLog);
  
  // Keep only last 100 completed flights in history
  if (flightHistory.length > 100) {
    flightHistory.shift();
  }
  
  console.log(`✈️ Flight ${flight.callsign} completed: ${flight.origin} → ${flight.destination}`);
}

// Create return flight from completed flight
function createReturnFlight(originalFlight) {
  const returnFlightId = `return-${nextReturnFlightId++}`;
  
  // Swap origin and destination for return journey
  const returnOrigin = { 
    code: originalFlight.destination, 
    lat: originalFlight.path[originalFlight.path.length - 1].lat,
    lon: originalFlight.path[originalFlight.path.length - 1].lon
  };
  
  const returnDestination = {
    code: originalFlight.origin,
    lat: originalFlight.path[0].lat,
    lon: originalFlight.path[0].lon
  };
  
  // Extract airline and generate new flight number
  const airlineCode = originalFlight.callsign.match(/^[A-Z0-9]+/)[0];
  const newFlightNumber = Math.floor(Math.random() * 9000) + 1000;
  
  // Create return flight with same color family but slightly different
  const originalColor = originalFlight.color;
  const colorMatch = originalColor.match(/rgba?\(([^)]+)\)/);
  let returnColor = originalColor;
  
  if (colorMatch) {
    const [r, g, b] = colorMatch[1].split(',').map(n => parseInt(n.trim()));
    // Slightly modify the color for the return flight
    const newR = Math.min(255, Math.max(0, r + (Math.random() * 40 - 20)));
    const newG = Math.min(255, Math.max(0, g + (Math.random() * 40 - 20)));
    const newB = Math.min(255, Math.max(0, b + (Math.random() * 40 - 20)));
    returnColor = `rgba(${Math.round(newR)}, ${Math.round(newG)}, ${Math.round(newB)}, 0.5)`;
  }
  
  // Create the return flight
  const returnFlight = createFlight(
    returnOrigin, 
    returnDestination, 
    returnColor, 
    returnFlightId, 
    airlineCode, 
    newFlightNumber
  );
  
  // Set start time for return flight (1-4 hours after original landing)
  const turnaroundDelay = (1 + Math.random() * 3) * 60 * 60 * 1000; // 1-4 hours in milliseconds
  returnFlight.actualStartTime = Date.now() + turnaroundDelay;
  returnFlight.isReturnFlight = true;
  returnFlight.originalFlightId = originalFlight.id;
  returnFlight.progress = 0; // Start at beginning
  
  console.log(`🔄 Return flight created: ${returnFlight.callsign} (${returnDestination.code} → ${returnOrigin.code})`);
  
  return returnFlight;
}

// Check for flights that should generate return flights
function processCompletedFlights() {
  flightData.forEach((flight, index) => {
    const now = Date.now();
    const elapsedTime = now - flight.actualStartTime;
    const progress = elapsedTime / flight.plannedDuration;
    
    // Check if flight has just completed and not already processed
    if (progress >= 1 && !completedFlightIds.has(flight.id)) {
      // Mark as completed
      completedFlightIds.add(flight.id);
      
      // Log the completed flight
      logCompletedFlight(flight, now);
      
      // Decide if this flight should have a return journey
      if (Math.random() < returnFlightProbability && !flight.isReturnFlight) {
        // Create return flight
        const returnFlight = createReturnFlight(flight);
        
        // Add return flight to system
        flightData.push(returnFlight);
        planeDivs[returnFlight.id] = createPlane(returnFlight);
        leafletMarkers[returnFlight.id] = createPlaneMarker(returnFlight);
        pathCanvases[returnFlight.id] = createPathCanvas(returnFlight);
        
        console.log(`📊 Total flights now: ${flightData.length} (including ${Object.keys(flightData).filter(f => flightData[f].isReturnFlight).length} return flights)`);
      }
    }
  });
}

// Get flight history statistics
function getFlightHistoryStats() {
  return {
    totalCompleted: flightHistory.length,
    returnFlights: flightData.filter(f => f.isReturnFlight).length,
    activeFlights: flightData.length,
    completionRate: flightHistory.length > 0 ? (flightHistory.length / (flightHistory.length + flightData.length)) * 100 : 0
  };
}

// Console command to view flight history (for debugging)
window.showFlightHistory = function() {
  console.log("=== FLIGHT HISTORY ===");
  console.log(`Total completed flights: ${flightHistory.length}`);
  console.log(`Active flights: ${flightData.length}`);
  console.log(`Return flights: ${flightData.filter(f => f.isReturnFlight).length}`);
  console.log("\nRecent completions:");
  
  flightHistory.slice(-10).forEach(log => {
    const duration = Math.round(log.totalDuration / 60000);
    const timeAgo = Math.round((Date.now() - log.completionTime) / 60000);
    console.log(`✈️ ${log.callsign}: ${log.origin}→${log.destination} (${duration}min flight, ${timeAgo}min ago)`);
  });
  
  console.log("\nType showFlightHistory() to refresh");
};

// Calculate realistic flight duration based on distance and aircraft performance
function calculateFlightDuration(flight) {
  if (!flight.distanceNM || !flight.cruiseSpeed) {
    return "N/A";
  }
  
  const distance = flight.distanceNM;
  const cruiseSpeed = flight.cruiseSpeed;
  
  // Realistic flight time calculation with phases
  // 20% climb, 60% cruise, 20% descent = different speeds
  const climbDistance = distance * 0.20;
  const cruiseDistance = distance * 0.60;
  const descentDistance = distance * 0.20;
  
  // Realistic speeds for each phase
  const climbSpeed = cruiseSpeed * 0.65; // Slower during climb
  const cruiseSpeedActual = cruiseSpeed; // Full cruise speed
  const descentSpeed = cruiseSpeed * 0.75; // Slower during descent
  
  // Calculate time for each phase (in hours)
  const climbTime = climbDistance / climbSpeed;
  const cruiseTime = cruiseDistance / cruiseSpeedActual;
  const descentTime = descentDistance / descentSpeed;
  
  // Add taxi, takeoff, and landing time (15-30 minutes depending on airport)
  const groundTime = distance < 200 ? 0.25 : distance < 1000 ? 0.4 : 0.5; // hours
  
  const totalHours = climbTime + cruiseTime + descentTime + groundTime;
  
  // Format duration
  const hours = Math.floor(totalHours);
  const minutes = Math.round((totalHours - hours) * 60);
  
  if (hours === 0) {
    return `${minutes} min`;
  } else if (minutes === 0) {
    return `${hours}hr`;
  } else {
    return `${hours}hr, ${minutes} min`;
  }
}

// Calculate remaining flight time based on progress
function calculateRemainingTime(flight, progress) {
  if (!flight.distanceNM || !flight.cruiseSpeed || progress >= 1) {
    return "Arrived";
  }
  
  const remainingDistance = flight.distanceNM * (1 - progress);
  
  // Estimate remaining time based on current phase
  let avgRemainingSpeed;
  if (progress < 0.20) {
    // Still climbing - mix of climb and cruise speeds ahead
    avgRemainingSpeed = flight.cruiseSpeed * 0.8;
  } else if (progress < 0.75) {
    // In cruise - mostly cruise speed ahead
    avgRemainingSpeed = flight.cruiseSpeed * 0.9;
  } else {
    // In descent - slower speeds ahead
    avgRemainingSpeed = flight.cruiseSpeed * 0.7;
  }
  
  const remainingHours = remainingDistance / avgRemainingSpeed;
  const hours = Math.floor(remainingHours);
  const minutes = Math.round((remainingHours - hours) * 60);
  
  if (hours === 0) {
    return `${minutes} min remaining`;
  } else if (minutes === 0) {
    return `${hours}hr remaining`;
  } else {
    return `${hours}hr, ${minutes} min remaining`;
  }
}