<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Flight Tracker</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #f5f5f5;
    }
    
    #map-container {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background-color: #e8e0d8;
      overflow: hidden;
    }
    
    #flight-map {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    /* Simple plane marker */
    .plane {
      position: absolute;
      opacity: 0.6;
      font-size: 22px;
      font-family: monospace;
      color: #3239be;
      text-shadow: 0 0 2px #fff;
      transform-origin: 50% 50%;
      pointer-events: auto;
      cursor: pointer;
    }
    
    /* Flight paths */
    .path {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    /* Map features */
    .map-feature {
      position: absolute;
      color: #999;
      font-size: 12px;
      pointer-events: none;
    }
    
    /* Rivers */
    .river {
      position: absolute;
      background-color: #a7c4e2;
      opacity: 0.5;
      border-radius: 50%;
      pointer-events: none;
    }
    
    /* State borders */
    .border {
      position: absolute;
      border-top: 1px dashed #bbb;
      width: 100%;
      pointer-events: none;
    }
    
    /* Airport markers */
    .airport {
      position: absolute;
      width: 10px;
      height: 10px;
      margin-left: -5px;
      margin-top: -5px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.1);
      border: 1px solid #5362c2;
      pointer-events: none;
    }
    
    .airport-label {
      position: absolute;
      font-size: 10px;
      font-weight: bold;
      color: #2f3eb1;
      margin-left: 10px;
      margin-top: 5px;
      text-shadow: 0 0 2px white;
      pointer-events: none;
    }
    
    /* Tooltip styling */
    .tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: Arial, sans-serif;
      white-space: nowrap;
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
  </style>
</head>
<body>

<div id="map-container">
  <div id="flight-map">
    <!-- Map features will be added here -->
  </div>
</div>

<script>
// Map configuration
const MAP_WIDTH = window.innerWidth;
const MAP_HEIGHT = window.innerHeight;
const MAP_BOUNDS = {
  west: -100.0,
  east: -80.0,
  south: 35.0,
  north: 45.0
};

// Track animation state
let flightData = [];
let planeDivs = {};
let pathCanvases = {};
let animationRunning = false;

// Add some static map features
function addMapFeatures() {
  const map = document.getElementById('flight-map');
  
  // Add state borders (simple dashed lines)
  const borders = [
    { lat: 41.5, label: "Iowa/Missouri Border" },
    { lat: 40.0, label: "Kansas/Nebraska Border" },
    { lat: 37.0, label: "Oklahoma/Kansas Border" }
  ];
  
  borders.forEach(border => {
    const y = convertLatToY(border.lat);
    const borderDiv = document.createElement('div');
    borderDiv.className = 'border';
    borderDiv.style.top = y + 'px';
    map.appendChild(borderDiv);
  });
  
  // Add city labels
  const cities = [
    { name: "Lincoln", lat: 40.8, lon: -96.7 },
    { name: "Omaha", lat: 41.3, lon: -96.0 },
    { name: "Kansas City", lat: 39.1, lon: -94.6 },
    { name: "Topeka", lat: 39.0, lon: -95.7 },
    { name: "North Platte", lat: 41.1, lon: -100.8 },
    { name: "Salina", lat: 38.8, lon: -97.6 },
    { name: "Saint Joseph", lat: 39.8, lon: -94.8 },
    { name: "Norfolk", lat: 42.0, lon: -97.4 }
  ];
  
  cities.forEach(city => {
    const x = convertLonToX(city.lon);
    const y = convertLatToY(city.lat);
    
    const cityDiv = document.createElement('div');
    cityDiv.className = 'map-feature';
    cityDiv.textContent = city.name;
    cityDiv.style.left = (x + 5) + 'px';
    cityDiv.style.top = y + 'px';
    map.appendChild(cityDiv);
  });
  
  // Add simple rivers (blue dots)
  const rivers = [
    { lat: 41.5, lon: -96.5, size: 15 },
    { lat: 39.5, lon: -95.0, size: 20 },
    { lat: 40.2, lon: -98.5, size: 12 },
    { lat: 38.0, lon: -97.0, size: 18 },
    { lat: 42.0, lon: -97.0, size: 15 },
    { lat: 39.0, lon: -96.0, size: 25 },
    { lat: 38.5, lon: -99.5, size: 15 },
    { lat: 41.2, lon: -95.8, size: 20 },
    { lat: 37.8, lon: -93.5, size: 15 }
  ];
  
  rivers.forEach(river => {
    const x = convertLonToX(river.lon);
    const y = convertLatToY(river.lat);
    
    const riverDiv = document.createElement('div');
    riverDiv.className = 'river';
    riverDiv.style.left = (x - river.size/2) + 'px';
    riverDiv.style.top = (y - river.size/2) + 'px';
    riverDiv.style.width = river.size + 'px';
    riverDiv.style.height = river.size + 'px';
    map.appendChild(riverDiv);
  });
  
  // Add "United States" label
  const usLabelDiv = document.createElement('div');
  usLabelDiv.className = 'map-feature';
  usLabelDiv.textContent = "United States";
  usLabelDiv.style.left = (MAP_WIDTH / 2 - 40) + 'px';
  usLabelDiv.style.top = (MAP_HEIGHT / 2 + 50) + 'px';
  usLabelDiv.style.fontSize = '16px';
  usLabelDiv.style.color = '#999';
  map.appendChild(usLabelDiv);
  
  // Add airports (as landmarks)
  const airports = [
    { code: "MCI", name: "Kansas City Int'l", lat: 39.2976, lon: -94.7139 },
    { code: "STL", name: "St. Louis Lambert", lat: 38.7499, lon: -90.3748 },
    { code: "MSP", name: "Minneapolis–Saint Paul", lat: 44.8848, lon: -93.2223 },
    { code: "OMA", name: "Omaha Eppley", lat: 41.3032, lon: -95.8940 },
    { code: "DSM", name: "Des Moines Int'l", lat: 41.5340, lon: -93.6631 },
    { code: "CLE", name: "Cleveland Hopkins", lat: 41.4124, lon: -81.8498 },
    { code: "IND", name: "Indianapolis Int'l", lat: 39.7169, lon: -86.2956 },
    { code: "CMH", name: "Columbus John Glenn", lat: 39.9999, lon: -82.8872 },
    { code: "PIT", name: "Pittsburgh Int'l", lat: 40.4915, lon: -80.2329 },
    { code: "CVG", name: "Cincinnati/Northern Kentucky", lat: 39.0489, lon: -84.6678 },
    { code: "BNA", name: "Nashville Int'l", lat: 36.1263, lon: -86.6774 },
    { code: "MEM", name: "Memphis Int'l", lat: 35.0420, lon: -89.9792 },
    // Add airports outside the map bounds for flights entering/exiting the region
    { code: "ORD", name: "Chicago O'Hare", lat: 41.9742, lon: -87.9073 },
    { code: "DTW", name: "Detroit Metro", lat: 42.2162, lon: -83.3554 },
    { code: "DFW", name: "Dallas/Fort Worth", lat: 32.8998, lon: -97.0403 },
    { code: "DEN", name: "Denver Int'l", lat: 39.8561, lon: -104.6737 },
    { code: "IAH", name: "Houston George Bush", lat: 29.9902, lon: -95.3368 },
    { code: "ATL", name: "Atlanta Hartsfield-Jackson", lat: 33.6407, lon: -84.4277 }
  ];
  
  // Filter airports that are within the map bounds
  const visibleAirports = airports.filter(airport => {
    return airport.lon >= MAP_BOUNDS.west &&
           airport.lon <= MAP_BOUNDS.east &&
           airport.lat >= MAP_BOUNDS.south &&
           airport.lat <= MAP_BOUNDS.north;
  });
  
  visibleAirports.forEach(airport => {
    const x = convertLonToX(airport.lon);
    const y = convertLatToY(airport.lat);
    
    // Airport marker
    const airportDiv = document.createElement('div');
    airportDiv.className = 'airport';
    airportDiv.style.left = x + 'px';
    airportDiv.style.top = y + 'px';
    map.appendChild(airportDiv);
    
    // Airport label
    const labelDiv = document.createElement('div');
    labelDiv.className = 'airport-label';
    labelDiv.textContent = airport.code;
    labelDiv.style.left = x + 'px';
    labelDiv.style.top = y + 'px';
    map.appendChild(labelDiv);
  });
}

// Convert latitude to Y coordinate
function convertLatToY(lat) {
  const latRange = MAP_BOUNDS.north - MAP_BOUNDS.south;
  const normalizedLat = (MAP_BOUNDS.north - lat) / latRange;
  return normalizedLat * MAP_HEIGHT;
}

// Convert longitude to X coordinate
function convertLonToX(lon) {
  const lonRange = MAP_BOUNDS.east - MAP_BOUNDS.west;
  const normalizedLon = (lon - MAP_BOUNDS.west) / lonRange;
  return normalizedLon * MAP_WIDTH;
}

// Convert coordinates to pixel positions
function coordsToPixels(lat, lon) {
  return {
    x: convertLonToX(lon),
    y: convertLatToY(lat)
  };
}

// bearing in degrees, 0° = North, clockwise positive
function calculateHeading(startLat, startLon, endLat, endLon) {
  const dLon = endLon - startLon;
  const dLat = endLat - startLat;
  let bearing = Math.atan2(dLon, dLat) * 180 / Math.PI;
  return (bearing + 360) % 360;          // normalised 0-359
}

// Create a flight with perfectly straight paths
function createFlight(start, end, color, id, airline, flightNumber) {
  const pathPoints = [];
  const numPoints = 200; // Increase point density for smoother paths
  
  // Calculate points along a perfectly straight line
  for (let j = 0; j < numPoints; j++) {
    const t = j / (numPoints - 1);
    
    // Pure linear interpolation - direct path
    const lat = start.lat + (end.lat - start.lat) * t;
    const lon = start.lon + (end.lon - start.lon) * t;
    
    pathPoints.push({ lat, lon });
  }
  
  // Calculate the exact heading
  const exactHeading = calculateHeading(start.lat, start.lon, end.lat, end.lon);
  
  // Apply same heading to all points
  pathPoints.forEach(point => {
    point.angle = exactHeading;
  });
  
  return {
    id,
    callsign: `${airline}${flightNumber}`,
    origin: start.code,
    destination: end.code,
    path: pathPoints,
    color,
    progress: Math.random() // Random initial position
  };
}

// Generate random flight data (250 flights across US central area)
function generateFlights() {
  const flights = [];
  const numRandomFlights = 250; // Increased density for visibility
  
  // Airlines codes
  const airlines = ['AA', 'UA', 'DL', 'WN', 'F9', 'AS', 'NK', 'B6'];
  
  // Standard airport coordinates with some extras to ensure good distribution
  const airports = [
    { code: "MCI", name: "Kansas City", lat: 39.3, lon: -94.7 },
    { code: "STL", name: "St. Louis", lat: 38.7, lon: -90.4 },
    { code: "OMA", name: "Omaha", lat: 41.3, lon: -96.0 },
    { code: "DSM", name: "Des Moines", lat: 41.5, lon: -93.7 },
    { code: "MSP", name: "Minneapolis", lat: 44.9, lon: -93.2 },
    { code: "CMH", name: "Columbus", lat: 40.0, lon: -82.9 },
    { code: "IND", name: "Indianapolis", lat: 39.7, lon: -86.3 },
    { code: "CVG", name: "Cincinnati", lat: 39.0, lon: -84.7 },
    { code: "MEM", name: "Memphis", lat: 35.0, lon: -90.0 }
  ];
  
  // Additional edge airports to ensure coverage of the whole map
  const edgePoints = [
    { code: "NW", name: "Northwest", lat: 44.9, lon: -99.5 },
    { code: "NE", name: "Northeast", lat: 44.9, lon: -80.5 },
    { code: "SW", name: "Southwest", lat: 35.1, lon: -99.5 },
    { code: "SE", name: "Southeast", lat: 35.1, lon: -80.5 },
    { code: "N", name: "North", lat: 44.9, lon: -90.0 },
    { code: "S", name: "South", lat: 35.1, lon: -90.0 },
    { code: "E", name: "East", lat: 40.0, lon: -80.5 },
    { code: "W", name: "West", lat: 40.0, lon: -99.5 },
    { code: "C1", name: "Center1", lat: 42.0, lon: -95.0 },
    { code: "C2", name: "Center2", lat: 38.0, lon: -95.0 },
    { code: "C3", name: "Center3", lat: 40.0, lon: -90.0 },
    { code: "C4", name: "Center4", lat: 40.0, lon: -85.0 }
  ];
  
  // Combine main airports with edge points
  const allPoints = [...airports, ...edgePoints];
  
  // Create routes between airports
  for (let i = 0; i < numRandomFlights; i++) {
    // Pick random origin and destination
    const origin = allPoints[Math.floor(Math.random() * allPoints.length)];
    
    let destination;
    do {
      destination = allPoints[Math.floor(Math.random() * allPoints.length)];
    } while (destination.code === origin.code);
    
    // Create flight object
    const airline = airlines[Math.floor(Math.random() * airlines.length)];
    const flightNumber = Math.floor(Math.random() * 9000) + 1000; // 1000-9999
    const color = getRandomColor(i);
    
    flights.push(createFlight(origin, destination, color, `flight-${i}`, airline, flightNumber));
  }
  
  // Add specific diagonal cross flights for better distribution
  const crossFlights = [
    createFlight(edgePoints[0], edgePoints[3], "#FF9999", "cross-1", "AA", "1001"),
    createFlight(edgePoints[1], edgePoints[2], "#99FF99", "cross-2", "UA", "2002"),
    createFlight(edgePoints[4], edgePoints[5], "#9999FF", "cross-3", "DL", "3003"),
    createFlight(edgePoints[6], edgePoints[7], "#FFFF99", "cross-4", "WN", "4004")
  ];
  
  return [...flights, ...crossFlights];
}

// Get a random pastel color
function hexToRgba(hex, alpha = 0.5) {
  // strip leading “#” and expand shorthand (#abc → #aabbcc)
  const h = hex.replace('#', '');
  const bigint = h.length === 3
    ? parseInt(h.split('').map(c => c + c).join(''), 16)
    : parseInt(h, 16);

  const r = (bigint >> 16) & 255;
  const g = (bigint >>  8) & 255;
  const b =  bigint        & 255;

  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function getRandomColor(index, alpha = 0.5) {
  const accessibleColors = [
    '#0072B2', // blue
    '#E69F00', // orange
    '#009E73', // green
    '#CC79A7', // magenta
    '#56B4E9', // sky blue
    '#D55E00', // red-orange
    '#F0E442', // yellow
    '#6d2dac'  // deep purple
  ];
  return hexToRgba(accessibleColors[index % accessibleColors.length], alpha);
}

// Create a plane element
function createPlane(flight) {
  const map = document.getElementById('flight-map');
  
  // Create plane element
  const plane = document.createElement('div');
  plane.id = flight.id;
  plane.className = 'plane';
  plane.textContent = ':';                // ← ASCII plane nose-up baseline
  
  // Add data attributes for tooltip
  plane.dataset.callsign = flight.callsign;
  plane.dataset.origin = flight.origin;
  plane.dataset.destination = flight.destination;
  
  // Get the initial point
  const initialPoint = flight.path[0];
  
  // Set initial rotation
  plane.style.transform = `translate(-50%, -50%) rotate(${initialPoint.angle}deg)`;
  
  // Position at initial point
  const pixelPos = coordsToPixels(initialPoint.lat, initialPoint.lon);
  plane.style.left = pixelPos.x + 'px';
  plane.style.top = pixelPos.y + 'px';
  
  // Add hover event listeners
  plane.addEventListener('mouseenter', showTooltip);
  plane.addEventListener('mouseleave', hideTooltip);
  
  map.appendChild(plane);
  return plane;
}

// Create a canvas for drawing the flight path
function createPathCanvas(flight) {
  const map = document.getElementById('flight-map');
  
  // Create canvas for the flight path
  const canvas = document.createElement('canvas');
  canvas.width = MAP_WIDTH;
  canvas.height = MAP_HEIGHT;
  canvas.className = 'path';
  canvas.id = `path-${flight.id}`;
  
  map.appendChild(canvas);
  return canvas;
}

// Draw the flight path with trailing effect
function drawFlightPath(canvas, flight, progress) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Calculate the visible portion of the path (trailing effect)
  const trailLength = 0.24; // How much of the path to show behind the plane
  const startProgress = Math.max(0, progress - trailLength);
  
  // Find the start and end indices in the path array
  const startIdx = Math.floor(startProgress * (flight.path.length - 1));
  const endIdx = Math.floor(progress * (flight.path.length - 1));
  
  if (endIdx <= startIdx) return;
  
  // Draw the path with improved visibility
  ctx.beginPath();
  ctx.strokeStyle = flight.color;
  ctx.lineWidth = 2.0; // Increased thickness for better visibility
  ctx.setLineDash([4, 8]); // More visible dot spacing
  
  // Start point
  const startPoint = flight.path[startIdx];
  const startPixels = coordsToPixels(startPoint.lat, startPoint.lon);
  ctx.moveTo(startPixels.x, startPixels.y);
  
  // Draw line through all points in between
  for (let i = startIdx + 1; i <= endIdx; i++) {
    const point = flight.path[i];
    const pixels = coordsToPixels(point.lat, point.lon);
    ctx.lineTo(pixels.x, pixels.y);
  }
  
  ctx.stroke();
}

// Animation loop with linear movement
function animateFlights() {
  // Animation duration in seconds
  const cycleDuration = 480; // 8 minutes
  
  // Calculate current progress based on timestamp
  const now = Date.now() / 1000; // Current time in seconds
  const globalProgress = (now % cycleDuration) / cycleDuration;
  
  // Update each flight
  flightData.forEach(flight => {
    // Each flight has a slight offset for variety, but always between 0-1
    const flightProgress = (globalProgress + flight.progress) % 1;
    
    // Get the plane and path elements
    const plane = planeDivs[flight.id];
    const pathCanvas = pathCanvases[flight.id];
    
    // Update plane position - now using direct style updates without transitions
    updatePlanePosition(plane, flight, flightProgress);
    
    // Update flight path
    drawFlightPath(pathCanvas, flight, flightProgress);
  });
  
  // Continue animation loop
  requestAnimationFrame(animateFlights);
}

// Show tooltip with flight information
function showTooltip(event) {
  const plane = event.target;
  
  // Get current flight data
  const flightId = plane.id;
  const flight = flightData.find(f => f.id === flightId);
  
  if (!flight) return;
  
  // Find current position in the path
  const now = Date.now() / 1000;
  const cycleDuration = 480;
  const globalProgress = (now % cycleDuration) / cycleDuration;
  const flightProgress = (globalProgress + flight.progress) % 1;
  
  const exactIndex = flightProgress * (flight.path.length - 1);
  const index = Math.floor(exactIndex);
  
  // Get current position and calculate altitude
  const currentPoint = flight.path[index];
  
  // Calculate simulated altitude based on flight progress
  // Planes climb initially, cruise in the middle, and descend at the end
  let altitude;
  if (flightProgress < 0.1) {
    // Climbing
    altitude = Math.floor(flightProgress * 10 * 35000);
  } else if (flightProgress > 0.9) {
    // Descending
    altitude = Math.floor((1 - flightProgress) * 10 * 35000);
  } else {
    // Cruising with slight variations
    altitude = 35000 + Math.floor(Math.sin(flightProgress * 10) * 2000);
  }
  
  // Calculate ground speed (knots) - realistic for jet aircraft
  const speedFactor = 1 - 0.3 * Math.sin(flightProgress * Math.PI); // slower at takeoff/landing
  const groundSpeed = Math.floor(400 + speedFactor * 150);
  
  // Create or get tooltip element
  let tooltip = document.getElementById('tooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'tooltip';
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
  }
  
  // Update tooltip content with color indicator
  tooltip.innerHTML = `
    <div style="border-left: 4px solid ${flight.color}; padding-left: 6px;">
      <strong>${flight.callsign}</strong><br>
      ${flight.origin} → ${flight.destination}<br>
      ALT: ${altitude.toLocaleString()} ft<br>
      SPD: ${groundSpeed} kts<br>
      HDG: ${Math.round(currentPoint.angle)}°
    </div>
  `;
  
  // Position tooltip above the plane
  const planeRect = plane.getBoundingClientRect();
  tooltip.style.left = `${planeRect.left + planeRect.width/2}px`;
  tooltip.style.top = `${planeRect.top - tooltip.offsetHeight - 10}px`;
  tooltip.style.transform = 'translateX(-50%)';
  tooltip.style.opacity = '1';
}

// Hide tooltip
function hideTooltip() {
  const tooltip = document.getElementById('tooltip');
  if (tooltip) {
    tooltip.style.opacity = '0';
  }
}

// Update the position of a plane with direct positioning, no CSS transitions
function updatePlanePosition(plane, flight, progress) {
  // Find exact position in the flight path
  const exactIndex = progress * (flight.path.length - 1);
  const index = Math.floor(exactIndex);
  const nextIndex = Math.min(index + 1, flight.path.length - 1);
  
  // Calculate precise interpolation factor
  const t = exactIndex - index;
  
  // Get the current and next points
  const currentPoint = flight.path[index];
  const nextPoint = flight.path[nextIndex];
  
  // Precise linear interpolation between points
  const lat = currentPoint.lat + (nextPoint.lat - currentPoint.lat) * t;
  const lon = currentPoint.lon + (nextPoint.lon - currentPoint.lon) * t;
  
  // Use the pre-calculated angle
  const angle = currentPoint.angle;
  
  // Convert to screen coordinates
  const pixels = coordsToPixels(lat, lon);
  
  // Apply position and rotation directly
  plane.style.left = pixels.x + 'px';
  plane.style.top = pixels.y + 'px';
  plane.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
  
  // Update tooltip position if it's visible for this plane
  const tooltip = document.getElementById('tooltip');
  if (tooltip && tooltip.style.opacity === '1' && document.querySelector(':hover') === plane) {
    // If this plane is being hovered, update the tooltip position
    const planeRect = plane.getBoundingClientRect();
    tooltip.style.left = `${planeRect.left + planeRect.width/2}px`;
    tooltip.style.top = `${planeRect.top - tooltip.offsetHeight - 10}px`;
  }
}

// Handle window resize
function handleResize() {
  location.reload(); // Simplest way to handle resize for this demo
}

// Initialize the map and flights
function initializeMap() {
  // Add map features (borders, cities, etc.)
  addMapFeatures();
  
  // Generate flight data
  flightData = generateFlights();
  
  // Create plane and path elements for each flight
  flightData.forEach(flight => {
    // Create and store plane element
    planeDivs[flight.id] = createPlane(flight);
    
    // Create and store path canvas
    pathCanvases[flight.id] = createPathCanvas(flight);
  });
  
  // Start animation
  if (!animationRunning) {
    animationRunning = true;
    animateFlights();
  }
  
  // Add resize listener
  window.addEventListener('resize', handleResize);
}

// Initialize when the page loads
window.addEventListener('load', initializeMap);
</script>
</body>
</html>
